/*************************************************************************
 *
 * Copyright (c) 2018-2022, Lawrence Livermore National Security, LLC.
 * See the top-level LICENSE file for details.
 * Produced at the Lawrence Livermore National Laboratory
 *
 * SPDX-License-Identifier: MIT
 *
 ************************************************************************/
#include "Poisson.H"

#include "ElectricPotentialDriver.H"
#include "ElectricPotentialDriverFactory.H"
#include "PoissonSolverFactory.H"
#include "PoissonF.H"
#include "RestartManager.H"
#include "Loki_Defines.H"
#include "Interpolator4.H"
#include "Interpolator6.H"

namespace Loki {

const int Poisson::s_TAG_BATON = 4379;
const int Poisson::TIME_HISTS_PER_PROBE = 2;
const int Poisson::GLOBAL_TIME_HISTS = 5;
int Poisson::NUM_COLL_TIME_HISTS;

Poisson::Poisson(LokiInputParser& a_pp,
   const tbox::Pointer<ProblemDomain>& a_domain,
   int a_num_kinetic_species,
   int a_solution_order,
   int a_plot_times_per_file,
   bool a_plot_ke_vel_bdy_flux,
   bool a_coll_diag_on,
   double a_bz_const) //IEO
   : EMSolverBase(a_domain,
                  a_num_kinetic_species,
                  a_solution_order,
                  NUM_EM_VARS,
                  a_plot_times_per_file,
                  a_plot_ke_vel_bdy_flux,
                  a_coll_diag_on,
                  a_bz_const),
     m_apply_external_potential(false),
     m_ex_interp(0),
     m_ey_interp(0),
     m_rho_interp(0)
{
   NUM_COLL_TIME_HISTS = 8*a_num_kinetic_species;

   // Read all input related to this object.
   parseParameters(a_pp);

   // How to make collision diagnostics work with parallelized Poisson EM is not
   // so clear so for now we disallow it.
   if (m_number_of_procs > 1 && a_coll_diag_on) {
      LOKI_ABORT("Can not have collision diagnostics with parallelized Poisson EM.");
   }

   // The following code could probably be placed into parseParameters but
   // isn't because it involves parsing separate sub-databases of this Poisson.
   if (m_apply_external_potential) {
      // Get the sub-database for any external potential driver and create it.
      LokiInputParser epdf_pp("poisson.external_potential");
      m_ep_driver =
         ElectricPotentialDriverFactory::create(epdf_pp);
   }

   // The Poisson object writes restart data so register this object with the
   // RestartManager which will use the putToRestart/getFromRestart callbacks to
   // get the restart data written/read.
   RestartManager* restart_manager(RestartManager::getManager());
   restart_manager->registerRestart(this);
}


Poisson::Poisson(
   const Poisson& a_other)
   : EMSolverBase(a_other),
     m_ex_interp(0),
     m_ey_interp(0),
     m_rho_interp(0)
{
   // If the 2 Poissons are different copy their internals.
   if (this != &a_other) {
      m_ep_driver = a_other.m_ep_driver;
      m_apply_external_potential = a_other.m_apply_external_potential;
      buildInterpolators();
   }
}


Poisson::~Poisson()
{
   if (m_ex_interp) {
      for (int i = 0; i < m_solution_order; ++i) {
         delete [] m_ex_interp[i];
      }
      delete [] m_ex_interp;
   }
   if (m_ey_interp) {
      for (int i = 0; i < m_solution_order; ++i) {
         delete [] m_ey_interp[i];
      }
      delete [] m_ey_interp;
   }
   if (m_rho_interp) {
      for (int i = 0; i < m_solution_order; ++i) {
         delete [] m_rho_interp[i];
      }
      delete [] m_rho_interp;
   }
}


void
Poisson::createPartition(
   int a_proc_lo,
   int a_proc_hi,
   const MPI_Comm& a_comm)
{
   // Part common to all EMSolvers.
   createPartitionCommon(true, a_proc_lo, a_proc_hi, a_comm);
}


void
Poisson::initialize(
   LokiInputParser& a_pp,
   int a_num_species,
   bool a_plot_ke_vel_bdy_flux,
   bool a_coll_diag_on)
{
   // Create the Poisson solver and the array for the solved potential.
   // Currently, "parallel" solves of Poisson's equation are done by each
   // Poisson processor getting the serialized charge density and doing the
   // serial solve.  To make PETSc happy, the communicator in the serial solver
   // must contain only one processor.  So for "parallel" Poisson the serial
   // solver can't just be the communicator generated by the load balancer.  In
   // this case, each Poisson processor must create a communicator containing
   // only itself for the serial solver.
   if (isEMSolverProcessor()) {
      LokiInputParser solver_pp("poisson.solver");
      m_loki_solver = PoissonSolverFactory::create(solver_pp, *this);

      // Construct ParallelArray to hold the potential.
      deque<bool> is_periodic(CDIM);
      vector<int> num_cells(CDIM);
      for (int i = 0; i < CDIM; ++i) {
         // FOR NOW WE CAN ONLY ENFORCE PERIODIC BOUNDARY CONDITIONS ON THE
         // POISSON SOLVE.
         is_periodic[i] = true;
         num_cells[i] = m_domain->numberOfCells(i);
      }
      m_phi_solver.partition(CDIM,
         CDIM,
         m_proc_lo,
         m_proc_hi,
         m_n_ghosts,
         is_periodic,
         num_cells);

      // For parallel EM we need the serialized charge density and potential.
      if (m_number_of_procs > 1) {
         m_phi_global.partition(CDIM,
            CDIM,
            Loki_Utilities::s_my_id,
            Loki_Utilities::s_my_id,
            m_n_ghosts,
            is_periodic,
            num_cells);
         ParallelArray::Box base_space(CDIM);
         for (int d = 0; d < CDIM; ++d) {
            base_space.lower(d) = 0;
            base_space.upper(d) = m_domain->numberOfCells(d)-1;
         }
         m_rho_global.partition(base_space, CDIM, m_n_ghosts, num_cells);
      }
   }

   // Do the initialization common to all EMSolvers.
   initializeCommon(a_num_species, a_plot_ke_vel_bdy_flux, a_coll_diag_on);

   // Now we know enough to build the appropriate field interpolators if needed.
   buildInterpolators();
}


void
Poisson::buildInterpolators()
{
   // If this object is on the Poisson processor and there are either tracking
   // or noise source particles then we need to construct the interpolators of
   // the appropriate order.
   if (isEMSolverProcessor() &&
       (m_problem_num_tracking_particles > 0 ||
        m_problem_num_noise_source_particles > 0)) {
      if (m_solution_order == 4) {
         m_em_interpolator = new Interpolator4(*m_domain);
      }
      else {
         m_em_interpolator = new Interpolator6(*m_domain);
      }
      m_ex_interp = new double* [m_solution_order];
      m_ey_interp = new double* [m_solution_order];
      for (int i = 0; i < m_solution_order; ++i) {
         m_ex_interp[i] = new double [m_solution_order];
         m_ey_interp[i] = new double [m_solution_order];
      }
      if (m_problem_num_noise_source_particles > 0) {
         if (m_solution_order == 4) {
            m_rho_interpolator = new Interpolator4(*m_domain);
         }
         else {
            m_rho_interpolator = new Interpolator6(*m_domain);
         }
         m_rho_interp = new double* [m_solution_order];
         for (int i = 0; i < m_solution_order; ++i) {
            m_rho_interp[i] = new double [m_solution_order];
         }
      }
   }
}


bool
Poisson::conformsTo(
   const Poisson& a_other) const
{
   // If the 2 Poissons are different, check that they are defined on the same
   // piece of space and are partitioned the same.
   if (m_domain != a_other.m_domain ||
       m_proc_lo != a_other.m_proc_lo ||
       m_proc_hi != a_other.m_proc_hi ||
       m_partition_defined != a_other.m_partition_defined ||
       numTrackingParticles() != a_other.numTrackingParticles() ||
       numNoiseSourceParticles() != a_other.numNoiseSourceParticles()) {
      return false;
   }
   else {
      return true;
   }
}


void
Poisson::addData(
   const Poisson& a_increment_poisson,
   double a_factor,
   bool a_sum_reduce_inc)
{
   // Check that we're copying between similar Poissons and to each particle's
   // x, y, vx, and vy add a_factor times x, y, vx, and vy of the corresponding
   // particle in a_increment_poisson.
   if (conformsTo(a_increment_poisson)) {
      addParticleData(a_increment_poisson.m_tracking_particles,
         a_increment_poisson.m_noise_source_particles,
         a_factor,
         a_sum_reduce_inc);
   }
}


void
Poisson::copySolnData(
   const Poisson& a_rhs)
{
   // If the 2 Poissons are different copy each particles' x, y, vx, and vy.
   if (&a_rhs != this) {
      copyParticleData(a_rhs.m_tracking_particles,
                       a_rhs.m_noise_source_particles);
   }
}


void
Poisson::addNoiseToChargeDist(
   TimerManager* a_timers,
   ParallelArray& a_charge_density,
   double a_time)
{
   int num_noise_source_particles = numNoiseSourceParticles();
   if (num_noise_source_particles > 0) {
      a_timers->startTimer("Noisy Particles");
   }
   else {
      return;
   }

   // If there are noise source particles, add the contribution of each to the
   // net charge density.
   double x_lo = m_domain->lower(0);
   double x_hi = m_domain->upper(0);
   double dx = m_domain->dx(0);
   double nx = m_domain->numberOfCells(0);
   double y_lo = m_domain->lower(1);
   double y_hi = m_domain->upper(1);
   double dy = m_domain->dx(1);
   double ny = m_domain->numberOfCells(1);
   const ParallelArray::Box& interior_box = m_em_vars.interiorBox();
   int ib_x_lo = interior_box.lower(0);
   int ib_x_hi = interior_box.upper(0);
   int ib_y_lo = interior_box.lower(1);
   int ib_y_hi = interior_box.upper(1);
   const ParallelArray::Box& data_box = m_em_vars.dataBox();
   int db_x_lo = data_box.lower(0);
   int db_x_hi = data_box.upper(0);
   int db_y_lo = data_box.lower(1);
   int db_y_hi = data_box.upper(1);
   for (int i = 0; i < num_noise_source_particles; ++i) {
      // Check if this particle makes a contribution to the charge distribution
      // on this Poisson processor.
      const Particle& this_particle = m_noise_source_particles[i];
      double x_loc = this_particle.x();
      double y_loc = this_particle.y();
      int x_idx = (x_loc-x_lo)/dx;
      int y_idx = (y_loc-y_lo)/dy;
      double t_ramp = this_particle.startingTime();
      double envel;
      if (a_time < t_ramp) {
         envel = 0.5+0.5*tanh(8.0*a_time/t_ramp-4.0);
      }
      else {
         envel = 1.0;
      }

      // See if this particle is in the interior or ghost layer of this Poisson
      // processor.  If so, then it contributes to the charge distribution on
      // the processor.
      bool particle_contributes = x_idx >= db_x_lo && x_idx <= db_x_hi &&
         y_idx >= db_y_lo && y_idx <= db_y_hi;

      // If the particle is in the interior or the ghost layer of this domain
      // get its contribution.
      if (particle_contributes) {
         // Set the evaluation point to be the location of this particle.
         m_rho_interpolator->setEvaluationPoint(x_loc, y_loc);

         // Now compute the charge at the interpolating points that is required
         // to give the charge of this noise source particle.
         double noise_charge =
            envel*this_particle.charge()*this_particle.noiseSourceWeight();
         m_rho_interpolator->deterpolate(noise_charge, m_rho_interp);

         // Add the particle's contribution to the net charge density.
         for (int xidx = 0; xidx < m_solution_order; ++xidx) {
            int xGridIdx = m_rho_interpolator->xInterpolatingGridIndex(xidx);
            // If this part of the stencil is in the ghost layer then it does
            // not contribute to this processor's net charge density.
            if (xGridIdx < ib_x_lo || xGridIdx > ib_x_hi) {
               continue;
            }
            for (int yidx = 0; yidx < m_solution_order; ++yidx) {
               int yGridIdx = m_rho_interpolator->yInterpolatingGridIndex(yidx);
               // If this part of the stencil is in the ghost layer then it does
               // not contribute to this processor's net charge density.
               if (yGridIdx < ib_y_lo || yGridIdx > ib_y_hi) {
                  continue;
               }
               a_charge_density(xGridIdx, yGridIdx) += m_rho_interp[xidx][yidx];
            }
         }
      }

      // If part of the particle's stencil is outside the domain then the
      // periodic image of that part of the stencil may contribute to the
      // charge density on this processor.
      bool stencil_outside_domain =
         x_idx >= nx-(m_n_ghosts-1) || x_idx <= m_n_ghosts-1 ||
         y_idx >= ny-(m_n_ghosts-1) || y_idx <= m_n_ghosts-1;
      if (stencil_outside_domain) {
         // Set the evaluation point to be the location of this particle.
         m_rho_interpolator->setEvaluationPoint(x_loc, y_loc);

         // Now compute the charge at the interpolating points that is required
         // to give the charge of this noise source particle.
         double noise_charge =
            envel*this_particle.charge()*this_particle.noiseSourceWeight();
         m_rho_interpolator->deterpolate(noise_charge, m_rho_interp);

         // Add the particle's contribution to the net charge density.
         for (int xidx = 0; xidx < m_solution_order; ++xidx) {
            int xGridIdx = m_rho_interpolator->xInterpolatingGridIndex(xidx);
            // If the x grid index of this stencil point is outside the domain
            // then shift it to it's periodic image in x.
            int x_shift = 0;
            if (xGridIdx < 0) {
               x_shift = nx;
            }
            else if (xGridIdx >= nx) {
               x_shift = -nx;
            }
            xGridIdx += x_shift;
            for (int yidx = 0; yidx < m_solution_order; ++yidx) {
               int yGridIdx = m_rho_interpolator->yInterpolatingGridIndex(yidx);
               // If the y grid index of this stencil point is outside the
               // domain then shift it to it's periodic image in y.
               int y_shift = 0;
               if (yGridIdx < 0) {
                  y_shift = ny;
               }
               else if (yGridIdx >= ny) {
                  y_shift = -ny;
               }
               yGridIdx += y_shift;
               // If this stencil point is not outside the domain then ignore
               // it as we've already dealt with it.
               if (x_shift == 0 && y_shift == 0) {
                  continue;
               }
               // If this stencil point's periodic image is not in the interior
               // of this domain then it does not contribute to this processor's
               // current density.
               if (xGridIdx < ib_x_lo || xGridIdx > ib_x_hi ||
                   yGridIdx < ib_y_lo || yGridIdx > ib_y_hi) {
                  continue;
               }
               a_charge_density(xGridIdx, yGridIdx) += m_rho_interp[xidx][yidx];
            }
         }
      }
   }
   a_timers->stopTimer("Noisy Particles");
}


void
Poisson::addExternalPotential(
   ParallelArray& a_phi_local,
   double a_time)
{
   // Get externally defined phi and add to a_phi_local.
   if (m_ep_driver && m_apply_external_potential) {
      ParallelArray phi_extern(a_phi_local);
      phi_extern = 0.0;
      m_ep_driver->evaluate(phi_extern, *m_domain, a_time);
      a_phi_local += phi_extern;
   }
}


void
Poisson::startBCTimer(
   TimerManager* a_timers)
{
   a_timers->startTimer("BC (Poisson)");
}


void
Poisson::stopBCTimer(
   TimerManager* a_timers)
{
   a_timers->stopTimer("BC (Poisson)");
}


void
Poisson::parseParameters(
   LokiInputParser& a_pp)
{
   // Get the Poisson specific inputs.
   // See if there is an external potential.
   string potential_str("false");
   a_pp.query("apply_external_potential", potential_str);
   m_apply_external_potential =
      potential_str.compare("false") == 0 ? false : true;

   // Now get the parameters common to all EMSolvers.
   parseParametersCommon(a_pp);
}


void
Poisson::printParameters() const
{
   // Print this Poisson's parameters and the parameters of the entities that it
   // holds and are not accessible elsewhere like the external potential driver.
   Loki_Utilities::printF("\n#*#*# Poisson #*#*#\n");
   Loki_Utilities::printF("  Number of Processsors    = %i\n",
      m_number_of_procs);
   Loki_Utilities::printF("  apply external potential = %s\n",
      m_apply_external_potential ? "true" : "false");
   if (!m_loki_solver.isNull()) {
      m_loki_solver->printParameters();
   }
   if (!m_ep_driver.isNull() && m_apply_external_potential) {
      m_ep_driver->printParameters();
   }
}


void
Poisson::evalRHS(
   Poisson& a_rhs,
   const ParallelArray& a_net_ext_efield,
   double a_time)
{
   // The RHS evaluation only applies to the evaluation of the equations of
   // motion of the particles.
   TimerManager* timers(TimerManager::getManager());
   timers->startTimer("Poisson RHS");

   if (numTrackingParticles() > 0) {
      timers->startTimer("Tracking Particles");
      evalRHSParticles(false, a_rhs, a_net_ext_efield, a_time);
      timers->stopTimer("Tracking Particles");
   }

   if (numNoiseSourceParticles() > 0) {
      timers->startTimer("Noisy Particles");
      evalRHSParticles(true, a_rhs, a_net_ext_efield, a_time);
      timers->stopTimer("Noisy Particles");
   }
   timers->stopTimer("Poisson RHS");
}


void
Poisson::evalRHSParticles(
   bool a_noise_source_particles,
   Poisson& a_rhs,
   const ParallelArray& a_net_ext_efield,
   double a_time)
{
   int num_particles = a_noise_source_particles ?
      numNoiseSourceParticles() : numTrackingParticles();
   const vector<Particle>& particles = a_noise_source_particles ?
      m_noise_source_particles : m_tracking_particles;
   vector<Particle>& rhs_particles = a_noise_source_particles ?
      a_rhs.m_noise_source_particles : a_rhs.m_tracking_particles;

   // For each particle use an interpolating polynomial to compute the E field
   // that it sees and update x, y, vx, and vy.
   double x_lo = m_domain->lower(0);
   double dx = m_domain->dx(0);
   double y_lo = m_domain->lower(1);
   double dy = m_domain->dx(1);
   const ParallelArray::Box& interior_box = m_em_vars.interiorBox();
   int ib_x_lo = interior_box.lower(0);
   int ib_x_hi = interior_box.upper(0);
   int ib_y_lo = interior_box.lower(1);
   int ib_y_hi = interior_box.upper(1);
   for (int i = 0; i < num_particles; ++i) {
      // Check if this particle is on this Poisson processor and that it is
      // time to begin to move it.
      const Particle& this_particle = particles[i];
      double x_loc = this_particle.x();
      double y_loc = this_particle.y();
      int x_idx = (x_loc-x_lo)/dx;
      int y_idx = (y_loc-y_lo)/dy;
      double starting_time =
         a_noise_source_particles ? 0.0 : this_particle.startingTime();
      if (a_time < starting_time ||
          x_idx < ib_x_lo || x_idx > ib_x_hi ||
          y_idx < ib_y_lo || y_idx > ib_y_hi) {
         continue;
      }
      Particle& rhs_particle = rhs_particles[i];
      // Set the evaluation point to be the location of this particle.
      m_em_interpolator->setEvaluationPoint(x_loc, y_loc);

      // Figure out Ex and Ey at each interpolating point.
      for (int xidx = 0; xidx < m_solution_order; ++xidx) {
         int xGridIdx = m_em_interpolator->xInterpolatingGridIndex(xidx);
         for (int yidx = 0; yidx < m_solution_order; ++yidx) {
            int yGridIdx = m_em_interpolator->yInterpolatingGridIndex(yidx);
            m_ex_interp[xidx][yidx] = m_em_vars(xGridIdx, yGridIdx, EX) +
               a_net_ext_efield(xGridIdx, yGridIdx, EX);
            m_ey_interp[xidx][yidx] = m_em_vars(xGridIdx, yGridIdx, EY) +
               a_net_ext_efield(xGridIdx, yGridIdx, EY);
         }
      }

      // Now compute Ex and Ey for this particle.
      double Ex_particle = m_em_interpolator->interpolate(m_ex_interp);
      double Ey_particle = m_em_interpolator->interpolate(m_ey_interp);

      // The new x/y is the old vx/vy.  The new vx/vy is E*q/m.
      double t_ramp =
         a_noise_source_particles ? this_particle.startingTime() : 0.0;
      double envel;
      if (a_time < t_ramp) {
         envel = 0.5+0.5*tanh(8.0*a_time/t_ramp-4.0);
      }
      else {
         envel = 1.0;
      }
      double qoverm = envel*this_particle.charge()/this_particle.mass();
      double vx = this_particle.vx();
      double vy = this_particle.vy();
      rhs_particle.x() = vx;
      rhs_particle.y() = vy;
      rhs_particle.vx() = (Ex_particle + m_bz_const*vy)*qoverm;//IEO
      rhs_particle.vy() = (Ey_particle - m_bz_const*vx)*qoverm;//IEO
   }
}


void
Poisson::plotCollision(
   double a_time,
   double a_dt,
   KineticSpeciesPtrVect const& a_kinetic_species,
   const vector<vector<double> >& a_sequences,
   const vector<string>& a_species_names,
   const vector<double>& a_time_seq,
   int a_saved_seq,
   int& a_saved_save,
   string& a_time_hist_file_name)
{
   bool is_lo_em_proc = Loki_Utilities::s_my_id == m_proc_lo;
   vector<string> frame_names;
   buildCollPlotNames(a_species_names, frame_names);
   if (static_cast<int>(a_kinetic_species.size()) !=
       static_cast<int>(a_species_names.size())) {
      LOKI_ABORT("Bug in Poisson::plotCollision");
   }

   // Write the plot data for each species.
   if (isEMSolverProcessor()) {
      m_field_writer_coll->startTimeSlice(a_time,
         a_dt,
         frame_names,
         is_lo_em_proc);
   }
   const ParallelArray::Box& data_box = m_diag_plot[0].dataBox();
   const ParallelArray::Box& local_box = m_diag_plot[0].localBox();
   for (int is(0); is < static_cast<int>(a_kinetic_species.size()); ++is) {
      int offset = 2*CollisionOperator::s_DIAGNOSTIC_WORK_SIZE * is;

      // Only copy from first collision operator. Should this be generalized?
      a_kinetic_species[is]->copyCollisionDiagnostics(0, m_diag_plot);

      if (isEMSolverProcessor()) {
         for (int plot = 0;
              plot < CollisionOperator::s_DIAGNOSTIC_WORK_SIZE;
              ++plot) {
            m_field_writer_coll->writeField(frame_names[offset+plot],
               m_diag_plot[offset+plot].getData(),
               data_box,
               local_box,
               m_n_ghosts);
         }
      }

      // Now get the moment fields
      a_kinetic_species[is]->copyMomentDiagnostics(m_diag_plot);

      if (isEMSolverProcessor()) {
         for (int plot = CollisionOperator::s_DIAGNOSTIC_WORK_SIZE;
              plot < 2*CollisionOperator::s_DIAGNOSTIC_WORK_SIZE;
              ++plot) {
            m_field_writer_coll->writeField(frame_names[offset+plot],
               m_diag_plot[offset+plot].getData(),
               data_box,
               local_box,
               m_n_ghosts);
         }
      }
   }
   if (isEMSolverProcessor()) {
      m_field_writer_coll->endTimeSlice(is_lo_em_proc);
   }

   vector<string> time_hist_names;
   buildCollTimeHistoryNames(a_species_names, time_hist_names);
   writeTimeHistories(a_sequences,
      time_hist_names,
      a_time_seq,
      a_saved_seq,
      a_saved_save,
      a_time_hist_file_name);

   // We finished saving another plot cycle.
   ++a_saved_save;
}


void
Poisson::plot(
   double a_time,
   double a_dt,
   const vector<vector<double> >& a_sequences,
   const vector<string>& a_species_names,
   const vector<double>& a_time_seq,
   const vector<vector<double> >& a_probes, 
   int a_num_probes,
   int a_saved_seq,
   int& a_saved_save,
   bool a_plot_ke_vel_bdy_flux,
   string& a_time_hist_file_name)
{
   vector<string> frame_names;
   buildPlotNames(a_plot_ke_vel_bdy_flux, a_species_names, frame_names);
   vector<string> time_hist_names;
   buildTimeHistoryNames(a_num_probes,
                         numProblemTrackingParticles(),
                         a_species_names,
                         time_hist_names);
   bool is_lo_em_proc = Loki_Utilities::s_my_id == m_proc_lo;
   bool multiple_em_procs = m_proc_lo != m_proc_hi;

   if (multiple_em_procs && !is_lo_em_proc) {
      MPI_Status status;
      int info;
      int prev_writer = Loki_Utilities::s_my_id-1;
      int err = MPI_Recv(&info,
         1,
         MPI_INT,
         prev_writer,
         s_TAG_BATON,
         MPI_COMM_WORLD,
         &status);
      if (err != MPI_SUCCESS) {
         LOKI_ABORT("Could not get OK from previous writer.");
      }
   }

   m_field_writer->startTimeSlice(a_time,
      a_dt,
      numTrackingParticles(),
      a_num_probes,
      a_probes,
      m_domain->numberOfCells(),
      frame_names,
      is_lo_em_proc);
   plotCommon(a_sequences,
              a_time_seq,
              a_num_probes,
              a_saved_seq,
              a_saved_save,
              a_time_hist_file_name,
              frame_names,
              time_hist_names);

   if (a_plot_ke_vel_bdy_flux) {
      // Write the plot data for each species following the same pattern as
      // above.
      const ParallelArray::Box& data_box = m_ke_flux_vx_lo[0].dataBox();
      const ParallelArray::Box& local_box = m_ke_flux_vx_lo[0].localBox();
      int num_species = static_cast<int>(a_species_names.size());
      int name_idx = NUM_EM_VARS;
      for (int is = 0; is < num_species; ++is) {
         // Write this species' vx lo ke flux to the next frame.
         m_field_writer->writeField(frame_names[name_idx++],
            m_ke_flux_vx_lo[is].getData(),
            data_box,
            local_box,
            m_n_ghosts);

         // Write this species' vx hi ke flux to the next frame.
         m_field_writer->writeField(frame_names[name_idx++],
            m_ke_flux_vx_hi[is].getData(),
            data_box,
            local_box,
            m_n_ghosts);

         // Write this species' vy lo ke flux to the next frame.
         m_field_writer->writeField(frame_names[name_idx++],
            m_ke_flux_vy_lo[is].getData(),
            data_box,
            local_box,
            m_n_ghosts);

         // Write this species' vy hi ke flux to the next frame.
         m_field_writer->writeField(frame_names[name_idx++],
            m_ke_flux_vy_hi[is].getData(),
            data_box,
            local_box,
            m_n_ghosts);
      }
   }
   m_field_writer->endTimeSlice(is_lo_em_proc);

   if (multiple_em_procs && Loki_Utilities::s_my_id != m_proc_hi) {
      int info = 0;
      int next_writer = Loki_Utilities::s_my_id+1;
      MPI_Send(&info, 1, MPI_INT, next_writer, s_TAG_BATON, MPI_COMM_WORLD);
   }

   // We finished saving another plot cycle.
   ++a_saved_save;
}

void
Poisson::accumulateCollisionSequences(
   vector<vector<double> >& a_sequences,
   int a_saved_seq,
   int& a_seq_idx)
{
  // Nothing to do here. Just call KineticSpecies::accumulateCollisionSequences
  // from VPSystem::accumulateCollisionSequences.
}

void
Poisson::accumulateSequences(
   vector<vector<double> >& a_sequences,
   const vector<vector<double> >& a_probes,
   int a_num_probes,
   int a_saved_seq,
   int& a_seq_idx)
{
   // Initialize the time history to 0.
   // EM time histories
   double e_sum_tot(0.0);
   double e_max(0.0);
   double e_tot(0.0);
   double ex_max(0.0);
   double ey_max(0.0);

   // Probe time histories
   vector<vector<double> > eProbe(TIME_HISTS_PER_PROBE);
   vector<vector<double> > eProbeTotal(TIME_HISTS_PER_PROBE);
   for (int ix(0); ix < TIME_HISTS_PER_PROBE; ++ix) {
      eProbe[ix].resize(a_num_probes, 0.0);
      eProbeTotal[ix].resize(a_num_probes, 0.0);
   }

   // Only processors onto which the Poisson calculation is distributed need to
   // do this.
   if (isEMSolverProcessor()) {
      // Get the interior box bounds.
      const int x_lo = m_em_vars.interiorBox().lower(0);
      const int x_hi = m_em_vars.interiorBox().upper(0);
      const int y_lo = m_em_vars.interiorBox().lower(1);
      const int y_hi = m_em_vars.interiorBox().upper(1);

      // Get some other misc quantities we'll need along the way.
      const tbox::IntVector N(m_domain->numberOfCells());
      const vector<double>& dx(m_domain->dx());
      const double area(dx[X1] * dx[X2]);

      // Compute the local parts of the E field time histories.
      for (int i2 = y_lo; i2 <= y_hi; ++i2) {
         for (int i1 = x_lo; i1 <= x_hi; ++i1) {
            const double ex = m_em_vars(i1, i2, EX);
            const double ey = m_em_vars(i1, i2, EY);
            double tmp = ex * ex + ey * ey;
            double e_loc = sqrt(tmp);
            e_sum_tot += 0.5*tmp;
            e_max = max(e_max, e_loc);
            e_tot += e_loc;
            ex_max = max(ex_max, fabs(ex));
            ey_max = max(ey_max, fabs(ey));
         }
      }
      // These are integrated over configuration space.
      e_sum_tot *= area;
      e_tot     *= area;

      // Compute the local part of the probe time histories.
      for (int np(0); np < a_num_probes; ++np) {
         const int ip(int(floor(a_probes[0][np] * N[X1])));
         const int jp(int(floor(a_probes[1][np] * N[X2])));
         if (ip >= x_lo && ip <= x_hi && jp >= y_lo && jp <= y_hi) {
            eProbe[EX][np] = m_em_vars(ip, jp, EX);
            eProbe[EY][np] = m_em_vars(ip, jp, EY);
         }
      }
   }

   // Now get the appropriate max/sum of the E field time histories from all the
   // processors and store to the time history.
   a_sequences[a_seq_idx++][a_saved_seq] =
      Loki_Utilities::getMaxValue(e_max, -1);
   a_sequences[a_seq_idx++][a_saved_seq] =
      Loki_Utilities::getSum(e_tot, -1);
   a_sequences[a_seq_idx++][a_saved_seq] =
      Loki_Utilities::getMaxValue(ex_max, -1);
   a_sequences[a_seq_idx++][a_saved_seq] =
      Loki_Utilities::getMaxValue(ey_max, -1);
   a_sequences[a_seq_idx++][a_saved_seq] =
      Loki_Utilities::getSum(e_sum_tot, -1);

   // Get the sum of the probe time histories from all the processors and store
   // to the time history.
   for (int i = 0; i < TIME_HISTS_PER_PROBE; ++i) {
      Loki_Utilities::getSums(&eProbe[i][0],
         &eProbeTotal[i][0],
         a_num_probes,
         -1);
   }
   for (int ip(0); ip < a_num_probes; ++ip) {
      a_sequences[a_seq_idx++][a_saved_seq] = eProbeTotal[EX][ip];
      a_sequences[a_seq_idx++][a_saved_seq] = eProbeTotal[EY][ip];
   }

   // Store the tracking particle positions and velocities to the time history.
   for (int ip = 0; ip < numTrackingParticles(); ++ip) {
      const Particle& tracking_particle = m_tracking_particles[ip];
      a_sequences[a_seq_idx++][a_saved_seq] = tracking_particle.x();
      a_sequences[a_seq_idx++][a_saved_seq] = tracking_particle.y();
      a_sequences[a_seq_idx++][a_saved_seq] = tracking_particle.vx();
      a_sequences[a_seq_idx++][a_saved_seq] = tracking_particle.vy();
   }
}


void
Poisson::getFromRestart(
   RestartReader& a_reader)
{
   // No restart data needs to be read.
   NULL_USE(a_reader);
}


void
Poisson::putToRestart(
   RestartWriter& a_writer,
   double a_time)
{
   NULL_USE(a_time);
   bool write_data = Loki_Utilities::s_my_id == m_proc_lo;
   putToRestartCommon(a_writer);
   a_writer.writeIntegerValue("isMaxwell", 0, write_data);
}


void
Poisson::buildTimeHistoryNames(
   int a_num_probes,
   int a_num_tracking_particles,
   const vector<string>& a_species_names,
   vector<string>& a_time_hist_names)
{
   ostringstream th_name;
   int num_species = static_cast<int>(a_species_names.size());
   a_time_hist_names.push_back("E_max");
   a_time_hist_names.push_back("norm E");
   a_time_hist_names.push_back("Ex_max");
   a_time_hist_names.push_back("Ey_max");
   a_time_hist_names.push_back("field_energy");
   for (int ip = 0; ip < a_num_probes; ++ip) {
      th_name << "Ex_probe" << ip;
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");

      th_name << "Ey_probe" << ip;
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
   }
   for (int ipart = 0; ipart < a_num_tracking_particles; ++ipart) {
      th_name << "particle" << ipart << "_x";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << "particle" << ipart << "_y";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << "particle" << ipart << "_vx";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << "particle" << ipart << "_vy";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
   }
   for (int is = 0; is < num_species; ++is) {
      th_name << a_species_names[is] << "_ke";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_ke_x";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_ke_y";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_px";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_py";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_xlo_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_xhi_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_ylo_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_yhi_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_vxlo_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_vxhi_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_vylo_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_vyhi_flux";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_ke_e_dot";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_integrated_ke_e_dot";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_driver_time_envel";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
   }
}


void
Poisson::buildCollTimeHistoryNames(
   const vector<string>& a_species_names,
   vector<string>& a_time_hist_names)
{
   ostringstream th_name;
   int num_species = static_cast<int>(a_species_names.size());
   for (int is = 0; is < num_species; ++is) {
      th_name << a_species_names[is] << "_dMomX";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_dMomY";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_dKE";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_dEnt";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_iMomX";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_iMomY";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_iKE";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
      th_name << a_species_names[is] << "_iEnt";
      a_time_hist_names.push_back(th_name.str());
      th_name.str("");
   }
}


void
Poisson::buildPlotNames(
   bool a_plot_ke_vel_bdy_flux,
   const vector<string>& a_species_names,
   vector<string>& a_plot_names)
{
   a_plot_names.push_back("EX");
   a_plot_names.push_back("EY");
   if (a_plot_ke_vel_bdy_flux) {
      int num_species = static_cast<int>(a_species_names.size());
      for (int i = 0; i < num_species; ++i) {
         ostringstream plot_name;
         plot_name << a_species_names[i] << " ke flux vx lo";
         a_plot_names.push_back(plot_name.str());
         plot_name.str("");
         plot_name << a_species_names[i] << " ke flux vx hi";
         a_plot_names.push_back(plot_name.str());
         plot_name.str("");
         plot_name << a_species_names[i] << " ke flux vy lo";
         a_plot_names.push_back(plot_name.str());
         plot_name.str("");
         plot_name << a_species_names[i] << " ke flux vy hi";
         a_plot_names.push_back(plot_name.str());
         plot_name.str("");
      }
   }
}


void
Poisson::buildCollPlotNames(
   const vector<string>& a_species_names,
   vector<string>& a_plot_names)
{
   int num_species = static_cast<int>(a_species_names.size());
   for (int i = 0; i < num_species; ++i) {
      ostringstream plot_name;
      plot_name << a_species_names[i] << " diag MomX";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " diag MomY";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " diag KE";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " diag Ent";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " MomX";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " MomY";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " KE";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
      plot_name << a_species_names[i] << " Ent";
      a_plot_names.push_back(plot_name.str());
      plot_name.str("");
   }
}

} // end namespace Loki
