\documentclass[11pt]{amsart}
\usepackage{geometry}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{Loki Tutorial}
\author{Bill Arrighi}
\thanks{LLNL-SM-737619}
\date{August 18, 2017}

\begin{document}
\maketitle
\section*{Introduction}
Loki is a parallel code for the solution of the coupled Vlasov-Poisson or
Vlasov-Maxwell equations.  It consists of 2 separate programs.  The first is
the actual parallel simulation code and is named vlasovPoisson4D.  The
second is a serial post-processing tool named vp4DPostProcess.  Despite the
name, the simulation code is able to solve both the Vlasov-Poisson and the
Vlasov-Maxwell systems.  The system to be solved is specified in the user's
input deck the details of which will be discussed below.

The parallel simulation code produces a number of output files containing the
fields and time histories relevent to the simulation.  The serial
post-processor may be run to serialize the field and time history data from
these output files.  Several large files containing the 4D distribution
functions of the kinetic species in the problem are produced.  In addition,
smaller files containing the 2D fields and the 1D time histories generated by
the simulation are generated.  The details of the contents of these files are
discussed below in the section about Output Files.

There is also a serial utility named testDist which will read an input deck and
number of Vlasov processors and compute and print the smallest partition in each
dimension.  If the partition is less than the required stencil width, a warning
for that dimension will also be printed.  This allows a user to avoid the pain
of submitting a large job and waiting for it to eventually run only to discover
that the problem has been overdecomposed and can not run.

\section*{Building Loki}
Loki requires several external packages including Metis, ParMetis, SuperLU, \\
SuperLU\_dist, PETSc, A++P++, and Overture.  We will describe how to build and
organize these packages below.  Although Loki needs many separate packages
the instructions given below to build these packages will result in a directory
structure such that a single, top-level path is all that Loki's configure
script needs in order to find all these packages.

\subsubsection*{External Packages}
These instructions have been written explicitly for LLNL's LC TOSS3 computers.
It is likely that they will work for an LC CHAOS (TOSS2) system as well.  The
instructions worked largely unchanged to build the packages on Jeff Bank's
computer at RPI.

Note that under TOSS3 there are serious issues mixing compilers.  Specifically,
it was not possible to get a good build if GNU C++ and C compilers were used in
conjunction with the PGI Fortran compiler.  Thus, these instructions are
written to build all the external packages with the GNU compiler suite.  It is
likely that these restrictions may be relaxed when building on a CHOAS (TOSS2)
machine.

All the external packages except for A++P++ and Overture have a traditional
notion of separate build and install locations.  Thus, for all packages except
these two you may untar and build wherever you wish.  The installation process
places the necessary components into the requested installation location.
A++P++ and Overture must be built in-place.  Hence you must untar and build
these packages exactly where they will be installed.

Here are the instructions to build each external package.  They should be built
in the order in which they appear in these instructions.  All packages will
be installed in sub-directories of \$INST\_DIR.  On LC's TOSS3 systems
INST\_DIR was \\
/usr/gapps/valhalla/LOKI/PACKAGES\_TOSS3.

Before doing anything: \\
ml gcc/4.9.3

Build METIS: \\
You need metis\_4.0.3 which is part of parmetis\_4.0.3.
\begin{enumerate}
\item cd to the directory in which you will build METIS
\item tar xvzf parmetis-4.0.3.tar.gz
\item cd parmetis-4.0.3/metis
\item setenv METIS\_INST \$INST\_DIR/METIS\_4.0.3
\item make config cc="path to C compiler" prefix="\$METIS\_INST"
\item make
\item make install
\end{enumerate}

Build PARMETIS: \\
These instructions assume that you just built METIS and follow directly from
the final METIS build step.
\begin{enumerate}
\item cd .. \\
This should put you in the top level directory of the PARMETIS distribution.
\item setenv PARMETIS\_INST \$INST\_DIR/PARMETIS\_4.0.3
\item make config cc="path to C compiler MPI wrapper" cxx="path to C++ compiler
MPI wrapper" prefix="\$PARMETIS\_INST"
\item make
\item make install
\item cd ..
\item rm -rf parmetis-4.0.3
\end{enumerate}

Build SUPERLU: \\
You need superlu\_4.3.  Note that the README file for this package is quite
misleading.  The default and install make targets do not work.
\begin{enumerate}
\item cd to the directory in which you will build SUPERLU
\item tar xvzf superlu\_4.3.tar.gz
\item cd SuperLU\_4.3
\item cp MAKE\_INC/make.linux make.inc
\item Edit make.inc:
\begin{enumerate}
\item Edit SuperLUroot to point to where you've untarred everything.
\item You may need to edit BLASLIB to point to where libblas lives.  We needed
to make it /usr/lib64
\item Edit CC to point to the C compiler.
\item Edit FORTRAN to point to the fortran compiler.
\item You may need to edit CDEFS, we didn't need to.
\item Ignore MATLAB.
\end{enumerate}
\item make superlulib
\item As stated above, the install target does not work so you need to do the
following:
\begin{enumerate}
\item setenv SUPERLU\_INST \$INST\_DIR/SUPERLU\_4.3
\item Ensure that \$SUPERLU\_INST contains a lib and an include directory.
\item cp SRC/*.h \$SUPERLU\_INST/include
\item cp lib/libsuperlu\_4.3.a \$SUPERLU\_INST/lib
\item cd \$SUPERLU\_INST/lib
\item ln -s libsuperlu\_4.3.a libsuperlu.a
\end{enumerate}
\item You may now rm -rf SuperLU\_4.3 from wherever you built SUPERLU.
\end{enumerate}

Build SUPERLU\_DIST: \\
You need superlu\_dist\_3.3-p1.  The build process is similar to superlu above
and the same caveats about the README and default/install make targets apply.
\begin{enumerate}
\item cd to the directory in which you will build SUPERLU\_DIST
\item tar xvzf superlu\_dist\_3.3-p1.tar.gz
\item cd SuperLU\_DIST-3.3-p1
\item cp MAKE\_INC/make.i386\_linux make.inc
\item Edit make.inc:
\begin{enumerate}
\item Edit DSuperLUroot to point to where you've untarred everything.
\item Get rid of the /lib in DSUPERLULIB.
\item You may need to edit BLASLIB to point to where libblas lives.  We needed
to make it /usr/lib64
\item Modify METISLIB and PARMETISLIB to indicate where the metis and \\
parmetis libs are.  If you installed metis in \$METIS\_INST and parmetis in
\$PARMETIS\_INST you'll need: \\
METISLIB = -L\$METIS\_INST/lib -lmetis \\
PARMETISLIB = -L\$PARMETIS\_INST/lib -lparmetis
\item  Edit CC to point to the C compiler MPI wrapper.
\item Edit FORTRAN to point to the fortran compiler MPI wrapper.
\item You may need to edit CDEFS, we didn't need to.
\end{enumerate}
\item We needed to edit SRC/xerbla.c to add \\
\#include \textless stdio.h \textgreater
\item make superlulib
\item Again, the install target does not work so you need to do the following:
\begin{enumerate}
\item setenv SUPERLU\_DIST\_INST \$INST\_DIR/SUPERLU\_DIST\_3.3-p1
\item Ensure that \$SUPERLU\_DIST\_INST contains a lib and and include
directory.
\item cp SRC/*.h \$SUPERLU\_DIST\_INST/include
\item cp libsuperlu\_dist\_3.3.a \$SUPERLU\_DIST\_INST/lib
\item cd \$SUPERLU\_DIST\_INST/lib
\item ln -s libsuperlu\_dist\_3.3.a libsuperlu\_dist.a
\item To avoid confusion should you end up with multiple builds of Overture
that need different versions of METIS and PARMETIS it is useful to do the
following in \$SUPERLU\_DIST\_INST: \\
ln -s ../METIS\_4.0.3 METIS \\
ln -s ../PARMETIS\_4.0.3 PARMETIS
\end{enumerate}
\item You may now rm -rf SupreLU\_DIST-3.3-p1 from wherever you built \\
SUPERLU\_DIST.
\end{enumerate}

Build PETSc: \\
You need PETSc 3.4.5.  When configuring PETSc we didn't need and in fact could
not use --with-cc, --with-cxx, or --with-fc due to PETSc's configure script's
assumptions and where the TOSS3 machines put the compilers/mpi.  This may not
hold for another architecture.
\begin{enumerate}
\item cd to the directory in which you will build PETSc
\item tar xvzf petsc-3.4.5.tar.gz
\item cd petsc-3.4.5
\item setenv PETSC\_INST \$INST\_DIR/PETSc\_3.4.5
\item ./configure --configModules=PETSc.Configure \\
--optionsModule=PETSc.compilerOptions --PETSC\_ARCH=linux-gnu-opt \\
--with-mpi-dir="/usr/tce/packages/mvapich2/mvapich2-2.2-gcc-4.9.3" \\
--with-debugging=0 --with-matlab=0 \\
--with-superlu-include="\$SUPERLU\_INST/include" \\
--with-superlu-lib="\$SUPERLU\_INST/lib/libsuperlu\_4.3.a" \\
--with-superlu\_dist-include="\$SUPERLU\_DIST\_INST/include" \\
--with-superlu\_dist-lib="\$SUPERLU\_DIST\_INST/lib/libsuperlu\_dist\_3.3.a" \\
--prefix="\$PETSC\_INST" --with-shared-libraries=0 \\
--with-parmetis-include="\$PARMETIS\_INST/include" \\
--with-parmetis-lib="\$PARMETIS\_INST/lib/libparmetis.a" \\
--with-metis-include="\$METIS\_INST/include" \\
--with-metis-lib="\$METIS\_INST/lib/libmetis.a"
\item Run the make command that configure tells you to run.
\item Run the make install command that make tells you to run.
\item cd .. \\
rm -rf petsc-3.4.5
\item cd \$PETSC\_INST \\
ln -s ../SUPERLU\_4.3 SUPERLU \\
ln -s ../SUPERLU\_DIST\_3.3-p1 SUPERLU\_DIST
\end{enumerate}

Build A++P++: \\
Unlike the other external packages, A++P++ does not install the necessary
pieces of it's distribution and your build of it (libs and includes) to a
separate installation directory.  Instead it does an "in place" installation
copying these pieces to a location embedded in the distribution itself.  So
you need to untar and build this package where you want it installed.
\begin{enumerate}
\item setenv A++P++\_DIR \$INST\_DIR/A++P++-0.8.0
\item cd \$INST\_DIR
\item tar xvzf A++P++-0.8.0.tar.gz
\item cd A++P++-0.8.0
\item Set the MPI\_ROOT environment variable to wherever your MPI installation
lives.  We needed: \\
setenv MPI\_ROOT /usr/tce/packages/mvapich2/mvapich2-2.2-gcc-4.9.3
\item ./configure --enable-PXX --prefix="\$A++P++\_DIR" --enable-SHARED\_LIBS \\
--with-mpi-include="-I's needed for mpi" \\
--with-mpi-lib-dirs="-L's and -Wl's needed for mpi" \\
--with-mpi-libs="-l's needed for mpi" \\
--without-PADRE --disable-mpirun-check \\
You may want --with-mpirun and not --disable-mpirun-check depending on the
nature of your machine.
\item make
\item make install
\end{enumerate}

Build Overture: \\
You need a version of Overture patched to support 6th order solution accuracy.
Like A++P++ Overture does not have a traditional notion of an installation
location so you will need to untar and build Overture where you want it
installed.  Also, Overture requires HDF5 which was already built on all
machines that we have used.  If this is not the case where you are building
Loki then you will need to download and build parallel HDF5.  Most of these
instructions are a repetition of those found in Overture's Installation
Instructions document.
\begin{enumerate}
\item cd \$INST\_DIR
\item tar xvzf OV.tar.gz
\item mv Overture\_dist Overture.6thorderfix
\item cd Overture.6thorderfix
\item Assuming that HDF5 is located in \$HDF5\_DIR, that OpenGL libs and
headers are found in lib64 and include subdirectories of OPENGL\_DIR set up the
following soft links:
\begin{enumerate}
\item ln -s \$A++P++\_DIR/P++/install A++
\item ln -s \$HDF5\_DIR HDF
\item ln -s \$OPENGL\_DIR OpenGL
\item ln -s \$PETSC\_INST PETSc
\end{enumerate}
\item Set up the following environment variables.  These are the settings for a
TOSS3 machine:
\begin{enumerate}
\item setenv MPI\_ROOT /usr/tce/packages/mvapich2/mvapich2-2.2-gcc-4.9.3
\item setenv XLIBS /usr
\item setenv OpenGL /usr
\item setenv MOTIF /usr
\item setenv HDF \$HDF5\_DIR
\item setenv APlusPlus \$A++P++\_DIR/P++/install
\item setenv LAPACK /usr/lib64
\item setenv Overture \$INST\_DIR/Overture.6thorderfix
\item setenv LD\_LIBRARY\_PATH /usr/lib64:\$HDF/lib: \\
\$INST\_DIR/Overture.6thorderfix/lib:\$A++P++\_DIR/P++/install/lib
\item setenv PPlusPlus \$A++P++\_DIR/P++/install
\item setenv PETSC\_ARCH linux-gnu-opt
\item setenv PETSC\_DIR \$PETSC\_INST
\item setenv PETSC\_LIB \$PETSC\_INST/lib
\end{enumerate}
\item ./configure opt parallel debugFlag="-g" precision=double CC=g++ cc=gcc \\
FC=gfortran
\item We found it necessary to edit DataBase/Makefile to put -I\$(HDF)/include
before \$(CCFLAGS).  We also found it necessary to edit Ogshow/Makefile to put
-I\$(HDF)/include before \$(CCFLAGS) and \$(CFLAGS).  Finally, we found it
necessary to edit bin/Makefile to get rid of -lmpio  These may be fixed in
newer versions of Overture.
\item make
\end{enumerate}

Now all the packages needed by Loki have been built and you may build Loki
itself.

\subsubsection*{Loki}
Now that the external packages have been built, Loki itself may be built.  Loki
may be built with either the GNU or Intel compiler suites.  As was noted above
with the external packages, mixing in a different Fortran compiler when
building on a TOSS3 machine will cause problems.

Loki's build system is based on the GNU configure and make utilities.  The
general process is to run configure passing it information about the compilers
to use, optional compiler flags, the location of the external packages, and
other build options such as whether to build an optimized or debugable version
of the code.  Note that although there are many separate external packages
needed by Loki, the instructions for building these pacakges created a
directory structure such that it is only necessary to pass one, top-level path
to Loki's configure script.  The configure script can find all the individual
packages from this one path if the the instructions for building the external
packages have been followed.

You can get a complete list of the options that configure may be given by
running ./configure --help from the command line.  Generally, you must give
configure a C++, C, and Fortran compiler.  There are several scripts whose
names all  begin with ``doinstall'' in the source code distribution that
describe the configure/make process for different compiler/machine combinations
at LLNL.

Once the code has been configured, simply type make from the command line to
compile and link the code.  Dependencies have been generated and stored in
Makefile.depend.  Therefore if modifications are made to the code it should
only be necessary to run make again.  If more extensive modifications are made
such as adding new header or source files the dependencies should be
regenerated.  This is done by running the script \\
``scripts/depend'' from the top-level directory of the source code
distribution.

\section*{Running Loki}
The details of how to run vlasovPoisson4D depend on the execute environment on
which the code is being run.  At LLNL, the general process is to construct an
msub script which contains an srun command to launch vlasovPoisson4D.  The
vlasovPoisson4D program itself takes only 1 argument, the name of the input
deck.  It produces a number of files which may be post-processed.  These files
all have a common root name which is specified in the input deck.

Once vlasovPoisson4D has been run, the serial post-processing tool
vp4DPostProcess may be run.  As this is a serial tool it may be run directly
from the command line.  There are only 2 arguments that this tool takes.  The
first is required and is the root name of the output files.  The second is an
option to not process the distribution functions.  As the post-processor is
serial, it may not be possible to process the distribution functions for large
problems due to the volume of the data.  The root name of the output is given
with -prefix=root and the option to not process the distributions is given with
-skip\_dists.  Thus to post-process a run that generated output with the root
name planeEPW, one would execute one of the following 2 commands: \\
vlasovPoisson4D -prefix=planeEPW \\
or \\
vlasovPoisson4D -prefix=planeEPW -skip\_dists

\section*{Input Decks}
\subsection*{Input Deck File Format}
Loki is invoked with 1 argument which is the name of the text file containing
the input parameters for the problem.  Input parameters are specified in a
hierarchical rather than a flat format.  Input parameters are organized into
hierarchical namespaces.  A "." indicates the start of an embedded namespace.
For example, the parameters relevant to the Poisson solve are specified in the
namespace beginning with "poisson.".  This will become clearer with specific
examples.  There is no required ordering of input parameters in the file
although grouping them in their hierarchical order makes reading the file much
easier.  One note is that there are cases where the "." character is part of a
namespace name.  Reserving this character for delimiting namespaces would have
been preferable.  However, the input format is simple enough that one can
fairly easily tell the use of a "." by context.

Each Loki input parameter must be one of the following 4 data types.
\begin{enumerate}
\item booleans: specified as either true or false (these are case sensitive)
\item reals: specified as decimal numbers or in scientific notation \\
       examples are 100, 100.0, 1.0e2
\item integers: specified as integer numbers
\item strings: specified as character strings delimited by the " character \\
         examples are "electron" and "Perturbed Maxwellian"
\end{enumerate}
Arrays of these data types are also allowed.  An array is specified as multiple
entries on the same line separated by a space such as 0.1 0.2 1.0.

Comments are allowed in the file.  Any line beginning with the "\#" character
is considered to be a comment.  Each input parameter is specified with a line
of the form: \\
parameter = value

It is frequently useful to define constants and build up numeric expressions
from these constants for use in an input file.  This can be done by embedding
Perl syntax in the file.  As these Perl expressions must be identified as such
so that they may be passed to the Perl interpreter they all must end with a
";".  Perl variables may then be referenced in the definition of Loki input
parameters.  Here is how something like this might look: \\
\# Perl expressions to define useful quantities \\
\$pi = 3.1415926535897932384626; \\
\$third = 1/3; \\
\$twelfth = 1/12; \\
\$xa = -3*\$pi; \\
\$xb =  3*\$pi; \\
\$xaK = -2.4375*\$pi; \\
\$xbK = 2.4375*\$pi; \\
\$ya = -78*\$pi; \\
\$yb =  78*\$pi; \\
\$vmax =  7; \\
\$vmin = -7; \\
\$Lx = 6*\$pi; \\
\$Ly = 288*\$pi; \\
...\\
\# Loki input parameters \\
\$domain\_limits = \$xa \$xb \$ya \$yb \\
...

It is not necessary to enforce any ordering on the input parameters.  Embedded
Perl code, however, will need to appear in the desired order of execution.

Loki has been normalized to electron thermal units.  Therfore, all input
parameters should be in these units.

We will now discuss the individual input parameters that control Loki.  For
each we will give their meaning, data type, any limits, any default values, and
notes concerning restrictions or relationships with other parameters.  The
parameters will be discussed in their hierarchical ordering.

\subsection*{General Simulation Parameters}
These parameters are in the top level namespace and describe general problem
control and scope.

spatial\_solution\_order
\begin{description}
\item [Description] Specifies the order of spatial accuracy of the solution.
\item [Data Type] Integer
\item [Default] 4
\item [Notes] Must be either 4 or 6.
\end{description}

temporal\_solution\_order
\begin{description}
\item [Description] Specifies the order of temporal accuracy of the solution.
\item [Data Type] Integer
\item [Default] 4
\item [Notes] Must be either 4 or 6.
\end{description}

verbosity
\begin{description}
\item [Description] If $>=$ 1 $\Delta$t is printed for each time step.
\item [Data Type] Integer
\item [Default] 1
\end{description}

cfl
\begin{description}
\item [Description] Sets the time step safety factor.
\item [Data Type] Real
\item [Default] 0.9
\end{description}

final\_time
\begin{description}
\item [Description] End simulation if this simulation time is reached.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

max\_step
\begin{description}
\item [Description] End simulation if this time step is reached.
\item [Data Type] Integer
\item [Default] 0
\item [Notes] As the default is 0 you had better enter something $>$ 0.
\end{description}

sequence\_write\_times
\begin{description}
\item [Description] Save 0D time histories such as energies, fluxes, and probe
information at multiples of this simulation time.  This data is written to
files whose naming is controlled by the show\_file\_name input parameter below.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

save\_times
\begin{description}
\item [Description] Save 2D configuration space arrays at multiples of this
simulation time.  This data is written to files whose naming is controlled by
the show\_file\_name input parameter below.
\item [Data Type] Real
\item [Default] 1.0
\item [Note] This time interval is strictly enforced.  Loki will adjust the
simulation time step so that a time step always ends at a multiple of this
time.  This also ensures that time histories are written out at a consistent
time interval.
\end{description}

save\_data
\begin{description}
\item [Description] If true time histories will be sampled and plot files
written.  If false you will not get any time histories or plots no matter
what was specified for sequence\_write\_times and save\_times.
\item [Data Type] Boolean
\item [Default] true
\end{description}

show\_file\_name
\begin{description}
\item [Description] Gives the root naming of plot files.
\item [Data Type] String
\item [Default] ex.show
\item [Notes] If you intend to use any Overture visualization or run the
post-processing tool this should be of the form xxx.show.  If the
post-processing tool is to be run, xxx should be the same as what is specified
in the restart.write\_directory input.
\end{description}

start\_from\_restart
\begin{description}
\item [Description] If true problem will restart from last saved restart.
Otherwise problem will start from initial conditions.
\item [Data Type] Boolean
\item [Default] false
\item [Notes] See RestartManager parameters for more on how to run from a
saved restart.
\end{description}

sys\_type
\begin{description}
\item [Description] Specify a Vlasov-Poisson (electrostatic) or Vlasov-Maxwell
(electrodynamic) system.
\item [Data Type] String
\item [Default] "poisson"
\item [Notes] Must be "poisson" or "maxwell".
\end{description}

number\_of\_probes
\begin{description}
\item [Description] The number of probes to sample.
\item [Data Type] Integer
\item [Default] 1
\item [Notes] Must be $>=$ 1.
\end{description}

probe.n.location
\begin{description}
\item [Description] An array of 2 values specifying the location of each probe
as a fraction of the configuration space extent in each direction.  Probes are
numbered starting from 1.  Therefore the command to place the first probe at a
location .25 the extent of the domain in x and .5 of the extent of the domain
in y would look like: \\
probe.1.location = 0.25 0.5
\item [Data Type] Real
\item [Default] 0.5 0.5
\end{description}

domain\_limits
\begin{description}
\item [Description] Upper and lower limits of each dimension of configuration
space specified as an array of the form: \\
domain\_limits = x\_lo x\_hi y\_lo y\_hi
\item [Data Type] Real
\item [Default] 0.0 1.0 0.0 1.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

periodic\_dir
\begin{description}
\item [Description] For each dimension of configuration space, if true apply
periodic boundary conditions in that dimension.  Otherwise do not.
\item [Data Type] Boolean
\item [Default] false false
\end{description}

N
\begin{description}
\item [Description] The number of cells in each dimension of configuration
space specified as an array of the form: \\
N = N$_\textnormal{x}$ N$_\textnormal{y}$
\item [Data Type] Integer
\item [Default] None.  This input is required
\item [Notes] N in each dimension must be at least the stencil width.  If the
spatial solution order is 4, then N $>=$ 5 in each dimension.  If the
spatial solution order is 6, then N $>=$ 7 in each dimension.
\end{description}

number\_of\_species
\begin{description}
\item [Description] Specifies the number of kinetic species in the problem.
\item [Data Type] Integer
\item [Default] 1
\end{description}

\subsection*{Parameters Describing Kinetic Species}
There is a variety of input associated with each kinetic species in the
problem.  The input parameters of each kinetic species are defined in separate
namespaces.  The namespace for the nth kinetic species is kinetic\_species.n
where n is one based.  Therefore to specify the name of the 1st kinetic species
as "electron" one would use the following syntax: \\
kinetic\_species.1.name = "electron"

name
\begin{description}
\item [Description] The name of the kinetic species.
\item [Data Type] String
\item [Default] None.  This input is required.
\end{description}

mass
\begin{description}
\item [Description] The mass of the kinetic species.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

charge
\begin{description}
\item [Description] The charge of the kinetic species.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

num\_external\_drivers
\begin{description}
\item [Description] Specifies the number of external electric field drivers for
this species.
\item [Data Type] Integer
\item [Default] 0
\end{description}

num\_collision\_operators
\begin{description}
\item [Description] Specifies the number of collision operators for this
species.
\item [Data Type] Integer
\item [Default] 0
\end{description}

velocity\_limits
\begin{description}
\item [Description] Upper and lower limits of each dimension of velocity space
specified as an array of the form: \\
kinetic\_species.n.velocity\_limits = vx\_lo vx\_hi vy\_lo vy\_hi
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

Nv
\begin{description}
\item [Description] The number of cells in each dimension of velocity space
specified as an array of the form: \\
kinetic\_species.n.velocity\_limits = N$_\textnormal{vx}$ N$_\textnormal{vy}$
\item [Data Type] Integer
\item [Default] None.  This input is required.
\end{description}

\subsection*{Parameters Describing Kinetic Species Initial Conditions}
There are 4 ways that initial conditions may be specicied.  The first 3 are
through the "Perturbed Maxwellian", "Landau damping", and
"Maxwellian with noise" initial conditions.  In this case the user
provides a set of input parameters and the code computes the complete initial
condition.  The fourth way is through an initial condition called 
"External 2D".  In this case the user precomputes and writes to an HDF5 file
the desired 2D configuration space distribution.  Input parameters describing
the velocity space dependency of the initial distribution are provided by the
user and the code combines the externally defined 2D distribution with this
velocity dependency to form the complete initial condition.

For any initial condition there is a variety of input that the user must
specify.  The input parameters of each kinetic species' initial condition are
defined in a sparate namespace of that kinetic species.  The namespace for the
initial condition of the nth kinetic species is kinetic\_species.n.ic where n
is one based.  Therefore to specify the name of the initial condition of the
1st kinetic species as "Perturbed Maxwellian" one would use the following
syntax: \\
kinetic\_species.1.ic.name = "Perturbed Maxwellian"

\subsubsection*{Perturbed Maxwellian, Landau damping, and Maxwellian with noise}
These 3 initial conditions are closely related.  As much of their input is
common they will be discussed together here.

The functional forms of these initial conditions in terms of their input
parameters are below.  In each case x1 is the x coordinate, x2 is the y
coordinate, x3 is the vx coordinate, x4 is the vy coordinate, and f is the
distribution function.  vflowx and vflowy are the vflowinitx and vflowinity
input parameters for the species being computed.

Common Definitions \\
\begin{math}vx = vx0*cos(x\_wave\_number*x1+y\_wave\_number*x2+phase)+vflowx\end{math} \\
\begin{math}vy = vy0*cos(x\_wave\_number*x1+y\_wave\_number*x2+phase)+vflowy\end{math}

Perturbed Maxwellian \\
\begin{math}f(x1,x2,x3,x4) = frac*alpha*beta/(2.0*\pi)*
  exp(-0.5*((alpha*(x3-vx))**2+(beta*(x4-vy))**2))*
  (1.0+A*cos(kx1*x1+spatial\_phase)*cos(ky1*x2+spatial\_phase)+
       B*cos(kx2*x1+spatial\_phase)+C*cos(ky2*x2+spatial\_phase))\end{math}

Landau damping \\
\begin{math}f(x1,x2,x3,x4) = frac*alpha*beta/(2.0*\pi)*
  exp(-0.5*((alpha*(x3-vx))**2+(beta*(x4-vy))**2))*
  (1.0+A*cos(kx1*x1+ky1*x2+spatial\_phase))\end{math}

Maxwellian with noise \\
Lx = length of configuration space in x dimension \\
noise = 1.0 \\
do k = 1,number\_of\_noisy\_modes \\
\indent \begin {math} noise = noise+noise\_amplitudes(k)*cos(2.0*\pi*k*(x1+noise\_phases(k))/Lx+spatial\_phase) \end{math} \\
end do \\
\begin{math}f(x1,x2,x3,x4) = noise*frac*alpha*beta/(2.0*\pi)*
  exp(-0.5*((alpha*(x3-vx))**2+(beta*(x4-vy))**2))\end{math}

These parameters apply to all 3 of these initial conditions: \\
\indent name
\begin{description}
\item [Description] The name of the initial condition.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Must be one of "Perturbed Maxwellian", "Landau damping", or
"Maxwellian with noise".
\end{description}

alpha
\begin{description}
\item [Description] Factor to control width of Maxwellian in vx.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

beta
\begin{description}
\item [Description] Factor to control width of Maxwellian in vy.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

vx0
\begin{description}
\item [Description] Amplitude of spatial perturbation of Maxwellian in vx.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

vy0
\begin{description}
\item [Description] Amplitude of spatial perturbation of Maxwellian in vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

frac
\begin{description}
\item [Description] Relative weight of this kinetic species.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

x\_wave\_number
\begin{description}
\item [Description] Wave number in x of spatial perturbation of Maxwellian in
vx and vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

y\_wave\_number
\begin{description}
\item [Description] Wave number in y of spatial perturbation of Maxwellian in
vx and vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

phase
\begin{description}
\item [Description] Phase of spatial perturbation of Maxwellian in vx and vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

spatial\_phase
\begin{description}
\item [Description] Phase of spatial perturbation of Maxwellian in x and y.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

These parameters apply to only "Perturbed Maxwellian" and "Landau damping": \\
\indent A
\begin{description}
\item [Description] One amplitude of spatial perturbation of Maxwellian in x
and y.  See functional forms above for use in each initial condition type.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

kx1
\begin{description}
\item [Description] Wave number in x of spatial perturbation of Maxwellian in
x having amplitude A.  See function forms above for use in each initial
condition type.
\item [Data Type] Real
\item [Default] 0.5
\end{description}

ky1
\begin{description}
\item [Description] Wave number in y of spatial perturbation of Maxwellian in
y having amplitude A.  See function forms above for use in each initial
condition type.
\item [Data Type] Real
\item [Default] 0.5
\end{description}

These parameters apply to only "Perturbed Maxwellian": \\
\indent B
\begin{description}
\item [Description] Amplitude of spatial perturbation of Maxwellian in x
controlled by kx2.  See functional form above for use.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

kx2
\begin{description}
\item [Description] Wave number in x of spatial perturbation of Maxwellian in
x having amplitude B.  See function form above for use.
\item [Data Type] Real
\item [Default] 0.5
\end{description}

C
\begin{description}
\item [Description] Amplitude of spatial perturbation of Maxwellian in y
controlled by ky2.  See functional form above for use.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

ky2
\begin{description}
\item [Description] Wave number in y of spatial perturbation of Maxwellian in
y having amplitude C.  See function form above for use.
\item [Data Type] Real
\item [Default] 0.5
\end{description}

These parameters apply to only "Maxwellian with noise": \\
\indent number\_of\_noisy\_modes
\begin{description}
\item [Description] Number of noise terms.
\item [Data Type] Integer
\item [Default] 0.0
\end{description}

noise\_amplitudes
\begin{description}
\item [Description] Amplitudes of each noise term specified as an array.
\item [Data Type] Real
\item [Default] None.  If number\_of\_noisy\_modes $>$ 0 this input is
required.
\item [Notes] There must be number\_of\_noisy\_modes values in the array.
\end{description}

noise\_phases
\begin{description}
\item [Description] Phases of each noise term specified as an array.
\item [Data Type] Real
\item [Default] None.  If number\_of\_noisy\_modes $>$ 0 this input is
required.
\item [Notes] There must be number\_of\_noisy\_modes values in the array.
\end{description}

\subsubsection*{External 2D}
As described above, the user will precompute the configuation space dependence
of the distribution function and write it to an HDF5 file.  The code applies
the velocity space dependence which will be described below.  In the examples
directory there is a problem set up to use this initial condition.  The 2D
distribution is generated with the Matlab script supplied with the problem.

The functional form of this initial condition is given below.  Here x1 is the
the x coordinate, x2 is the y coordinate, x3 is the vx coordinate, x4 is the vy
coordinate, the externally specified 2D distribution is extDist(x1, x2), and f
is the full 4D distribution function.  vflowx and vflowy are the vflowinitx and
vflowinity input parameters for the species being computed.

\begin{math}vx = vx0*cos(x\_wave\_number*x1+y\_wave\_number*x2+phase)+vflowx\end{math} \\
\begin{math}vy = vy0*cos(x\_wave\_number*x1+y\_wave\_number*x2+phase)+vflowy\end{math} \\
\begin{math}f(x1,x2,x3,x4) = alpha*beta/(2.0*\pi)*
  exp(-0.5*((alpha*(x3-vx))**2+(beta*(x4-vy))**2))*extDist(x1,x2)\end{math}

name
\begin{description}
\item [Description] The name of the initial condition.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Must "External 2D".
\end{description}

file\_name
\begin{description}
\item [Description] The name of the external 2D initial condition.
\item [Data Type] String
\item [Default] None.  This input is required.
\end{description}

alpha
\begin{description}
\item [Description] Factor to control width of Maxwellian in vx.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

beta
\begin{description}
\item [Description] Factor to control width of Maxwellian in vy.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

vx0
\begin{description}
\item [Description] Amplitude of spatial perturbation of Maxwellian in vx.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

vy0
\begin{description}
\item [Description] Amplitude of spatial perturbation of Maxwellian in vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

x\_wave\_number
\begin{description}
\item [Description] Wave number in x of spatial perturbation of Maxwellian in
vx and vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

y\_wave\_number
\begin{description}
\item [Description] Wave number in y of spatial perturbation of Maxwellian in
vx and vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

phase
\begin{description}
\item [Description] Phase of spatial perturbation of Maxwellian in vx and vy.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

\subsection*{Parameters Describing Kinetic Species Electric Field Drivers}
Multiple electric field drivers are permitted for each kinetic species.  The
input parameters for each electric field driver for a given kinetic species are
defined in separate namespaces of that kinetic species.  The input parameters
for the nth electric field driver for the mth kinetic species will be specified
in the namespace kinetic\_species.m.external\_driver.n where m and n are one
based.  Therefore to specify the name of the 2nd electric field driver of the
1st kinetic species one would use the following syntax: \\
kinetic\_species.1.external\_driver.2.name = "Shaped Ramped Cosine Driver"

Unlike the external potential driver, each electric field driver applies to a
specific kinetic species.  This is reflected in how the electric field drivers
are specified.  They are defined in a namespace of the kinetic species to which
they apply.

At the present time there is only one electric field driver, the Shaped Ramped
Cosine Driver.  The code is designed with an abstract driver class so that
new drivers derived from the abstract driver may be easily added.  The only
change to existing code needed is to add the new class to the driver factory.

The functional form of the Shaped Ramped Cosine Driver is given here.

\noindent if (t0 $<=$ t $<$ t0+t\_ramp) \\
\indent \begin{math}f(t) = 0.5+0.5*tanh(4.0*(2.0*(t-t0)/t\_ramp-1.0)) \end{math} \\
else if (t0+t\_ramp $<=$ t $<$ t0+t\_ramp+t\_off) \\
\indent \begin{math}f(t) = 0.5-0.5*tanh(4.0*(2.0*(t-t0-t\_off)/t\_ramp-1.0)) \end{math} \\
else \\
\indent \begin{math}f(t) = 0\end{math}

\noindent if (abs(x-x0) $<$ lwidth/2) \\
\indent \begin{math}g(x) = 1-x\_shape*(sin(\pi*(x-x0)/lwidth))**2\end{math} \\
else \\
\indent \begin{math}g(x) = 1-x\_shape\end{math}

\noindent if (abs(y) $<$ ywidth/2) \\
\indent \begin{math}h(y) = 1-shape*(sin(\pi*y/ywidth))**2\end{math} \\
else \\
\indent \begin{math}h(y) = 1-shape\end{math}

\noindent \begin{math}Ex\_ext = E\_0*f(t)*g(x)*h(y)*
         cos(\pi*x/xwidth-omega*(t-t0)+phase-0.5*alpha*(t-t0-t\_res)**2)\end{math} \\
\begin{math}Ey\_ext = 0.0\end{math}

name
\begin{description}
\item [Description] Name of driver.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Currently must be "Shaped Ramped Cosine Driver"
\end{description}

t0
\begin{description}
\item [Description] Time at which driver turns on.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

t\_ramp
\begin{description}
\item [Description] Ramp up time.  Driver ramps up from t0 to t0+t\_ramp.
\item [Data Type] Real
\item [Default] 10.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

t\_off
\begin{description}
\item [Description] Ramp down time.  Driver ramps down from t0+t\_ramp to \\
t0+t\_ramp+t\_off.
\item [Data Type] Real
\item [Default] 10.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

E\_0
\begin{description}
\item [Description] Amplitude of driver.
\item [Data Type] Real
\item [Default] 0.01
\end{description}

xwidth
\begin{description}
\item [Description] Half of a wavelength of modulation in x.
\item [Data Type] Real
\item [Default] 0.5
\item [Notes] Again, the default is almost certainly not what you want to use.
\end{description}

omega
\begin{description}
\item [Description] Frequency of external driver.
\item [Data Type] Real
\item [Default] 1.0
\item [Notes] Again, the default is almost certainly not what you want to use.
\end{description}

alpha
\begin{description}
\item [Description] Frequency like term in external driver.  Controls t**2
modulation of driver.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

t\_res
\begin{description}
\item [Description] Together with t0, determines center of t**2 modulation of
driver.  Center of t**2 modulation is at t0+t\_res.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

x0
\begin{description}
\item [Description] Center of shape function in x.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

lwidth
\begin{description}
\item [Description] Half of a wavelength of shape function in x.
\item [Data Type] Real
\item [Default] 0.5
\item [Notes] Again, the default is almost certainly not what you want to use.
\end{description}

x\_shape
\begin{description}
\item [Description] This is the amplitude of the shape function in x but in
practice it is more of a flag to shape between -xwidth/2 and xwidth/2 or
not.  A value of 0 results in no shaping in x.  A value of 1 results in
modulation between x0-lwidth/2 and x0+lwidth/2 and a constant 0 outside.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

ywidth
\begin{description}
\item [Description] Half of a wavelength of shape function in y.
\item [Data Type] Real
\item [Default] 0.5
\item [Notes] Again, the default is almost certainly not what you want to use.
\end{description}

shape
\begin{description}
\item [Description] This is the amplitude of the shape function in y but in
practice it is more of a flag to shape between -ywidth/2 and ywidth/2 or
not.  A value of 0 results in no shaping in y.  A value of 1 results in
modulation between -ywidth/2 and ywidth/2 and a constant 0 outside.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

phase\_decay\_time\_steps
\begin{description}
\item [Description] If you wish to apply a random phase to the driver this and
fwhm must be specified.  These control the calculation of the random phase
and it is best to consult the source as to how these are used.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

fwhm
\begin{description}
\item [Description] If you wish to apply a random phase to the driver this and \\
phase\_decay\_time\_steps must be specified.  These control the calculation
of the random phase and it is best to consult the source as to how these are
used.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

\subsection*{Parameters Describing Kinetic Species Collision Operators}
Multiple collision operators are permitted for each kinetic species.  The input
parameters for each collision operator for a given kinetic species are defined
in separate namespaces of that kinetic species.  The input parameters for the
nth collision operator for the mth kinetic species will be specified in the
namespace kinetic\_species.m.collision\_operator.n where m and n are one based.
Therefore to specify the name of the 2nd collision operator of the 1st kinetic
species one would use the following syntax:
kinetic\_species.1.collision\_operator.2.name = "Pitch Angle Collision Operator"

There are currently 2 collision operators, Pitch Angle Collision Operator and
Rosenbluth Collision Operator.

These parameters apply to both collision operators: \\
\indent name
\begin{description}
\item [Description] Name of collision operator.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Must be either "Pitch Angle Collision Operator" or "Rosenbluth
Collision Operator".
\end{description}

collision\_vceil
\begin{description}
\item [Description] Upper velocity limit used to compute collision rate.  The
collision rate for velocities $>=$ collision\_vceil is modulated by: \\
\begin{math} 1.0-sin^2(\pi/2*((v-collision\_vceil)/(vmax-collision\_vceil))) \end{math}
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

collision\_vfloor
\begin{description}
\item [Description] Lower velocity limit used to compute collision rate.  All
velocities below collision\_vfloor are set to collision\_vfloor.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

collision\_vthermal\_method
\begin{description}
\item [Description] Means by which vthermal is determined.  One may simply
enter a value, compute it via a global calculation of the mean distribution
function, or compute it via a processor local calculation of the mean
distribution function.
\item [Data Type] String
\item [Default] "input vthermal"
\item [Notes] Must be one of "input vthermal", "local vthermal", or
"global vthermal".  If "input vthermal" is selected then there must be an entry
for collision\_vthermal.  If "local vthermal" or "global vthermal" are
selected then there must not be an entry for collision\_vthermal as this is
contradictory.
\end{description}

collision\_vthermal
\begin{description}
\item [Description] The thermal velocity of the Kinetic Species associated with
this collision operator.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

collision\_vthermal\_dt
\begin{description}
\item [Description] The thermal velocity of the lighter Kinetic Species
involved in this collision operator.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

collision\_nuCoeff
\begin{description}
\item [Description] Collision damping.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

This parameter applies only to ``Pitch Angle Collision Operator'': \\
\indent collision\_conservative
\begin{description}
\item [Description] Controls use of conservative algorithm.  1 means use
conservative algorithm.  Other than 1 means use non-conservative algorithm.
\item [Data Type] Integer
\item [Default] 1
\item [Notes] If running with 6th order spatial accuracy, this must be 1.
\end{description}

These parameters apply only to ``Rosenbluth Collision Operator'': \\
\indent collision\_alpha
\begin{description}
\item [Description] This is the same as 1/vthermal.
\item [Data Type] Real
\item [Default] None.  This input is required.
\item [Notes] This is redundant.  It is the same as 1/vthermal.
\end{description}

collision\_back\_reaction
\begin{description}
\item [Description] If true, compute back reaction terms.
\item [Data Type] Boolean
\item [Default] false
\end{description}

collision\_massR
\begin{description}
\item [Description] Mass ration of collided and colliding species.
\item [Data Type] Real
\item [Default] None.  This input is required if collision\_back\_reaction is
true.
\end{description}

\subsection*{Parameters Describing Kinetic Species Krook Layer}
Each kinetic species can define a krook layer.  The input parameters of each
kinetic species' krook layer are defined in separate namespaces.  The namespace
for the krook layer of the nth kinetic species is kinetic\_species.n.krook
where n is one based.  Therefore to specify the power of the krook layer of the
1st kinetic species one would use the following syntax: \\
kinetic\_species.1.krook.power = 2

power
\begin{description}
\item [Description] Exponent in the evaluation of each layer.
\item [Data Type] Real
\item [Default] 3.0
\item [Notes] Must be $>$ 0.
\end{description}

coefficient
\begin{description}
\item [Description] Scaling in the evaluation of each layer.
\item [Data Type] Real
\item [Default] 1.0
\item [Notes] Must be $>$ 0.
\end{description}

x1a
\begin{description}
\item [Description] The coordinate of the lower end of layer in x.  If
specified, a krook layer at the lower end of x will be applied otherwise it
will not.
\item [Data Type] Real
\item [Default] No krook layer at lower end of x.
\item [Notes] Must be $>$ value for xmin in the domain\_limits parameter.  If
specified, the value for the x periodic\_dir must be false.
\end{description}

x1b
\begin{description}
\item [Description] The coordinate of the upper end of layer in x.  If
specified, a krook layer at the upper end of x will be applied otherwise it
will not.
\item [Data Type] Real
\item [Default] No krook layer at upper end of x.
\item [Notes] Must be $>$ value for xmax in the domain\_limits parameter.  If
specified, the value for the x periodic\_dir must be false.
\end{description}

x2a
\begin{description}
\item [Description] The coordinate of the lower end of layer in y.  If
specified, a krook layer at the lower end of y will be applied otherwise it
will not.
\item [Data Type] Real
\item [Default] No krook layer at lower end of y.
\item [Notes] Must be $>$ value for ymin in the domain\_limits parameter.  If
specified, the value for the y periodic\_dir must be false.
\end{description}

x2b
\begin{description}
\item [Description] The coordinate of the upper end of layer in y.  If
specified, a krook layer at the upper end of y will be applied otherwise it
will not.
\item [Data Type] Real
\item [Default] No krook layer at upper end of y.
\item [Notes] Must be $>$ value for ymax in the domain\_limits parameter.  If
specified, the value for the y periodic\_dir must be false.
\end{description}

\subsection*{Parameters Describing Electrostatic (Poisson) Algorithm}
Input parameters for the electrostatic algorithm are defined in the poisson
namespace.  Therefore to specify the method for the Poisson solve one would use
the following syntax: \\
poisson.solver\_method = "superlu direct"

solver\_method
\begin{description}
\item [Description] There are 3 different solvers, one direct and 2 iterative.
The iterative algorithms are older and are still in the code for
reproducibility of older runs.  We recommend using the direct solver which
is significantly faster.
\item [Data Type] String
\item [Default] "superlu direct"
\item [Notes] Must be "original iterative", "overture best iterative", or
"superlu direct".
\end{description}

solver\_tolerance
\begin{description}
\item [Description] This parameter controls the solver tolerance which only
applies to the iterative solvers.
\item [Data Type] Real
\item [Default] If using "original iterative" default is 1.0e-6, if using
"overture best iterative" default is 1.0e-12.
\end{description}

apply\_external\_potential
\begin{description}
\item [Description] It is possible to specify an externally applied potential.
Unlike the electric field drivers, the external potential is applied to each
kinetic species.  If an external potential is to be specified, then this should
be set to true.
\item [Data Type] Boolean
\item [Default] false
\end{description}

tracking\_particle\_file
\begin{description}
\item [Description] It is possible to track charged particles during a
simulation.  The tracking particles respond to the net self consistent E field
generated by the kinetic species present in the problem plus any externally
applied electric fields.  The initial 4D physical space location of each
particle is specified in an HDF5 file.  In addition, a time to start tracking
each particle is specified.  The name of the HDF5 file should be supplied with
this input parameter.  An example Matlab script to generate such a tracking
particle input file is in the examples directory.  The phase space coordinates
of each particle are saved as part of the time history output.  Note that these
particles are unrelated to the kinetic species in the problem.  They simply
allow one to visualize the respose of a given charged particle.
\item [Data Type] String
\item [Default] Empty string (no tracking particles specified).
\end{description}

\subsection*{Parameters Describing Electrostatic (Poisson) Algorithm External Potential Driver}
The input parameters for the external potential are defined in a separate
namespace, poisson.external\_potential.  Therefore to specify the amplitude of
the electrostatic algorithm external potential driver one would use the
following syntax: \\
poisson.external\_potential.amp = 0.01

Note that, unlike the electric field drivers, the external potential is not
specific to a particular kinetic species.  It is applied to each of the
species in the problem.

At the present time there is only one potential driver, the Shaped Ramped
Cosine Potential Driver.  The code is designed with an abstract driver class so
that new drivers derived from the abstract driver may be easily added.  The
only change to existing code needed is to add the new class to the driver
factory.

The functional form of the Shaped Ramped Cosine Potential Driver is largely
the same as for the Electric Field Driver: \\
\noindent if (t0 $<=$ t $<$ t0+t\_ramp) \\
\indent \begin{math} f(t) = 0.5+0.5*tanh(4.0*(2.0*(t-t0)/t\_ramp-1.0)) \end{math} \\
else if (t0+t\_ramp $<=$ t $<$ t0+t\_ramp+t\_off) \\
\indent \begin{math} f(t) = 0.5-0.5*tanh(4.0*(2.0*(t-t0-t\_off)/t\_ramp-1.0)) \end{math} \\
else \\
\indent \begin{math} f(t) = 0 \end{math}

\noindent if (abs(x-x0) $<$ lwidth/2) \\
\indent \begin{math} g(x) = 1-x\_shape*(sin(\pi*(x-x0)/lwidth))**2 \end{math} \\
else \\
\indent \begin{math} g(x) = 1-x\_shape \end{math}

\noindent if (abs(y) $<$ ywidth/2) \\
\indent \begin{math} h(y) = 1-shape*(sin(\pi*y/ywidth))**2 \end{math} \\
else \\
\indent \begin{math} h(y) = 1-shape \end{math}

\noindent \begin{math}phi\_ext = amp*f(t)*g(x)*h(y)*cos(\pi*x/xwidth-omega*(t-t0)) \end{math}

name
\begin{description}
\item [Description] Name of driver.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Currently must be "Shaped Ramped Cosine Potential Driver"
\end{description}

t0
\begin{description}
\item [Description] Time at which driver turns on.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

t\_ramp
\begin{description}
\item [Description] Ramp up time.  Driver ramps up from t0 to t0+t\_ramp.
\item [Data Type] Real
\item [Default] 10.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

t\_off
\begin{description}
\item [Description] Ramp down time.  Driver ramps down from t0+t\_ramp to \\
t0+t\_ramp+t\_off.
\item [Data Type] Real
\item [Default] 10.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

amp
\begin{description}
\item [Description] Amplitude of driver.
\item [Data Type] Real
\item [Default] 0.01
\end{description}

xwidth
\begin{description}
\item [Description] Half of a wavelength of modulation in x.
\item [Data Type] Real
\item [Default] 0.5
\item [Notes] Again, the default is most likely not what you want to use.
\end{description}

omega
\begin{description}
\item [Description] Frequency of external driver.
\item [Data Type] Real
\item [Default] 1.0
\item [Notes] Again, the default is most likely not what you want to use.
\end{description}

x0
\begin{description}
\item [Description] Center of shape function in x.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

lwidth
\begin{description}
\item [Description] Half of a wavelength of shape function in x.
\item [Data Type] Real
\item [Default] 0.5
\item [Notes] Again, the default is most likely not what you want to use.
\end{description}

x\_shape
\begin{description}
\item [Description] This is the amplitude of the shape function in x but in
practice it is more of a flag to shape between -xwidth/2 and xwidth/2 or
not.  A value of 0 results in no shaping in x.  A value of 1 results in
modulation between x0-lwidth/2 and x0+lwidth/2 and a constant 0 outside.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

ywidth
\begin{description}
\item [Description] Half of a wavelength of shape function in y.
\item [Data Type] Real
\item [Default] 0.5
\item [Notes] Again, the default is most likely not what you want to use.
\end{description}

shape
\begin{description}
\item [Description] This is the amplitude of the shape function in y but in
practice it is more of a flag to shape between -ywidth/2 and ywidth/2 or
not.  A value of 0 results in no shaping in y.  A value of 1 results in
modulation between -ywidth/2 and ywidth/2 and a constant 0 outside.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

\subsection*{Parameters Describing Electrodynamic (Maxwell) Algorithm}
Input parameters for the electrodynamic algorithm are defined in the maxwell
namespace.  To specify the speed of light for the electrodynamic algorithm one
would use the following syntax: \\
maxwell.light\_speed = 10.0

light\_speed
\begin{description}
\item [Description] Light speed.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

num\_current\_drivers
\begin{description}
\item [Description] It is possible to specify current drivers (sources) to be
used in the evaluation of the RHS of Maxwell's equations.  This indicates
how many current drivers there will be.
\item [Data Type] Integer
\item [Default] 0
\end{description}

num\_em\_ics
\begin{description}
\item [Description] Indicates the number of electromagnetic field initial
conditions.
\item [Data Type] Integer
\item [Default] None.  This input is required but 2 is the required input.
\item [Notes] This must be 2.  Not sure why we're making you put this in your
deck since you must initialize both E and B.
\end{description}

tracking\_particle\_file
\begin{description}
\item [Description] It is possible to track charged particles during a
simulation.  The tracking particles respond to the dynamic electromagnetic
field plus any externally applied electric fields.  The initial 4D physical
space location of each particle is specified in an HDF5 file.  In addition, a
time to start tracking each particle is specified.  The name of the HDF5 file
should be supplied with this input parameter.  An example Matlab script to
generate such a tracking particle input file is in the examples directory.
The phase space coordinates of each particle are saved as part of the time
history output.  Note that these particles are unrelated to the kinetic species
in the problem.  They simply allow one to visualize the respose of a given
charged particle.
\item [Data Type] String
\item [Default] Empty string (no tracking particles specified).
\end{description}

\subsection*{Parameters Describing Electrodynamic (Maxwell) Algorithm Current Drivers}
Multiple current drivers are permitted for the electrodynamic algorithm.  The
input parameters for each current driver for the electrodynamic algorithm are
defined in separate namespaces of the electrodynamic algorithm.  The input
parameters for the nth current driver will be specified in the namespace
maxwell.current\_driver.n where n is one based.  Therefore to specify the name
of the 2nd current driver of the electrodynamic algorithm one would use the
following syntax: \\
maxwell.current\_driver.2.name = "Shaped Ramped Cosine Current Driver"

At the present time there is only one current driver, the Shaped Ramped Cosine
Current Driver.  The code is designed with an abstract driver class so that
new drivers derived from the abstract driver may be easily added.  The only
change to existing code needed is to add the new class to the driver factory.

The Shaped Ramped Cosine Current Driver is a delta function in x.  It is
applied only at x=x0.  Its functional form is largely the same as for the
Electric Field Driver: \\
\noindent if (t0 $<=$ t $<$ t0+t\_ramp) \\
\indent \begin{math} f(t) = 0.5+0.5*tanh(4.0*(2.0*(t-t0)/t\_ramp-1.0)) \end{math} \\
else if (t0+t\_ramp $<=$ t $<$ t0+t\_ramp+t\_off) \\
\indent \begin{math} f(t) = 0.5-0.5*tanh(4.0*(2.0*(t-t0-t\_off)/t\_ramp-1.0)) \end{math} \\
else \\
\indent \begin{math} f(t) = 0 \end{math}

\noindent if (x == x0) \\
\indent \begin{math} g(x) = 1 \end{math} \\
else \\
\indent \begin{math} g(x) = 0 \end{math}

\noindent if (abs(y) $<$ width/2) \\
\indent \begin{math} h(y) = 1-shape*(sin(\pi*y/width))**2 \end{math} \\
else \\
\indent \begin{math} h(y) = 1-shape \end{math}

\noindent \begin{math} J\_ext = J\_0*f(t)*g(x)*h(y)*cos(omega*(t-t0)) \end{math}

name
\begin{description}
\item [Description] Name of driver.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Currently must be "Shaped Ramped Cosine Current Driver"
\end{description}

apply\_dir
\begin{description}
\item [Description] Indicates which component of the current this driver
controls.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Must be either "x", "y", "z", "X", "Y", or "Z".
\end{description}

t0
\begin{description}
\item [Description] Time at which driver turns on.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

t\_ramp
\begin{description}
\item [Description] Ramp up time.  Driver ramps up from t0 to t0+t\_ramp.
\item [Data Type] Real
\item [Default] 10.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

t\_off
\begin{description}
\item [Description] Ramp down time.  Driver ramps down from t0+t\_ramp to \\
t0+t\_ramp+t\_off.
\item [Data Type] Real
\item [Default] 10.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

J\_0
\begin{description}
\item [Description] Amplitude of driver.
\item [Data Type] Real
\item [Default] 0.01
\end{description}

omega
\begin{description}
\item [Description] Frequency of external driver.
\item [Data Type] Real
\item [Default] 1.0
\item [Notes] Although there is a default it is almost certainly not what you
want to use.
\end{description}

x0
\begin{description}
\item [Description] Location in x of current source.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

width
\begin{description}
\item [Description] Half of a wavelength of modulation in y.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

shape
\begin{description}
\item [Description] This is the amplitude of the shape function in y but in
practice it is more of a flag to shape between -ywidth/2 and ywidth/2 or
not.  A value of 0 results in no shaping in y.  A value of 1 results in
modulation between -ywidth/2 and ywidth/2 and a constant 0 outside.
\item [Data Type] Real
\item [Default] 1.0
\end{description}

\subsection*{Parameters Describing Electrodynamic (Maxwell) Algorithm  Field Initial Conditions }
It is necessary to specify initial conditions on both E and B.  The input
parameters for each of these initializers are defined in separate namespaces of
the electromagnetic algorithm.  The input parameters for the nth field
initializer will be specified in the namespace maxwell.em\_ic.n where n is one
based.  Therefore to specify the xamp of the 2nd field initializer of the
electrodynamic algorithm one would use the following syntax: \\
maxwell.em\_ic.2.xamp = 0.0001

At the present time there is only one field initializer, the SimpleEMIC.  The
code is designed with an abstract field initializer class so that new
initializers derived from the abstract initializer may be easily added.  The
only change to existing code needed is to add the new class to the field
initializer factory.

The SimpleEMIC is really simple.  It just initializes E or B to a standing
wave: \\
\begin{math} Ex = xamp*cos(x\_wave\_number*x+y\_wave\_number*y+phase) \end{math} \\
\begin{math} Ey = yamp*cos(x\_wave\_number*x+y\_wave\_number*y+phase) \end{math} \\
\begin{math} Ey = zamp*cos(x\_wave\_number*x+y\_wave\_number*y+phase) \end{math}

name
\begin{description}
\item [Description] Name of field initializer.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Currently must be "SimpleEMIC"
\end{description}

field
\begin{description}
\item [Description] Indicated which field, E or B, is being initialized.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Must be "e", "b", "E", or "B".
\end{description}

xamp
\begin{description}
\item [Description] Specifies the x amplitude of the field being initialized.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

yamp
\begin{description}
\item [Description] Specifies the y amplitude of the field being initialized.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

zamp
\begin{description}
\item [Description] Specifies the z amplitude of the field being initialized.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

x\_wave\_number
\begin{description}
\item [Description] Wave number of standing wave in x.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

y\_wave\_number
\begin{description}
\item [Description] Wave number of standing wave in y.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

phase
\begin{description}
\item [Description] Phase of standing wave.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

\subsection*{Parameters Describing Electrodynamic (Maxwell) Algorithm Drift Velocity Initial Conditions}
It is necessary to specify initial condition on the transverse drift velocity
of each kinetic species.  The input parameters for each of these initializers
are defined in separate namespaces of the electromagnetic algorithm.  The input
parameters for the transverse drift velocity of the nth kinetic species will
be specified in the namespace maxwell.vel\_ic.n where n is one based and
indicates the kinetic species.  Therefore to specify the amp of the 2nd
kinetic species transverse drift velocity initializer of the electrodynamic
algorithm one would use the following syntax: \\
maxwell.vel\_ic.2.amp = 0.0001

At the present time there is only one transverse drift velocity initializer,
the SimpleVELIC.  The code is designed with an abstract transverse drift
velocity initializer class so that new initializers derived from the abstract
initializer may be easily added.  The only change to existing code needed is
to add the new class to the transverse drift velocity initializer factory.

The SimpleVELIC is really simple.  It just initializes vz to a standing wave: \\
\begin{math} vz = amp*cos(x\_wave\_number*x+y\_wave\_number*y+phase) \end{math}

name
\begin{description}
\item [Description] Name of initializer.
\item [Data Type] String
\item [Default] None.  This input is required.
\item [Notes] Currently must be "SimpleVELIC"
\end{description}

amp
\begin{description}
\item [Description] Specifies the amplitude of the transverse drift velocity
being initialized.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

x\_wave\_number
\begin{description}
\item [Description] Wave number of standing wave in x.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

y\_wave\_number
\begin{description}
\item [Description] Wave number of standing wave in y.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

phase
\begin{description}
\item [Description] Phase of standing wave.
\item [Data Type] Real
\item [Default] None.  This input is required.
\end{description}

\subsection*{Parameters Describing RestartManager}
Several parameters control reading and writing restart files.  They are defined
in the restart namespace.  Therefore to specify the restart write\_directory
one would use the following syntax: \\
restart.write\_directory = "my\_dump\_file\_directory"

step\_interval
\begin{description}
\item [Description] This specifies the frequency in time steps at which restart
dumps will be written.  Restart dumps are written into the directory
specified by the write\_directory input parameter.
\item [Data Type] Integer
\item [Default] -1 which implies that the frequency for writing restart dumps
is not determined by time steps.
\item [Notes] You must specify one of step\_interval or time\_interval.  Both
may not be specified.  Must be $>$ 0.
\end{description}

time\_interval
\begin{description}
\item [Description] This specifies the frequency in simulation time at which
restart dumps will be written.  Restart dumps are written into the directory
specified by the write\_directory input parameter.
\item [Data Type] Real
\item [Default] -1.0 which implies that the frequency for writing restart dumps
is not determined by simulation time.
\item [Notes] You must specify one of step\_interval or time\_interval.  Both
may not be specified.  Must be $>$ 0.
\end{description}

write\_directory
\begin{description}
\item [Description] Indicates the directory into which all restart dumps are
written.
\item [Data Type] String
\item [Default] "."
\item [Notes] Although there is a default it is likely not what you want.  If
the post-processing tool is to be run, this needs to be consistent with the
show\_file\_name input.  See the comments for that input.
\end{description}

read\_directory
\begin{description}
\item [Description] If start\_from\_restart is true then you must specify where
to find the restart files with this input.
\item [Data Type] String
\item [Default] "."
\item [Notes] Although there is a default it is likely not what you want.  This
will be what write\_directory was on the run from which you want to restart.
If start\_from\_restart is false this input is not needed.
\end{description}

\subsection*{Advanced Parameters}
There are a few parameters that, although they may be set by the user, they
should be used with great care if at all.  Some of these parameters control
untested capabilities.  Some are hooks that may be needed for future
capabilities.  And others are algorithmic knobs intended primarily for
developmental experimentation.  Although they are described here for
completeness, we generally suggest that that not be set in user input decks.

\noindent General Simulation Parameters \\
\indent do\_new\_algorithm
\begin{description}
\item [Description] If true, use derivative based calculations.  Otherwise use
original flux based calculations.
\item [Data Type] Boolean
\item [Default] true
\end{description}

\noindent Parameters Describing Kinetic Species \\
\indent number\_of\_processors
\begin{description}
\item [Description] Each kinetic species is 4D and distributed over a set of
processors.  If you wish to control the number of processors that a kinetic
species is distributed over you would specify it here.  Otherwise Overture
will determine the distribution based on the work load of each species.  It
is best to let Overture determine the distribution.  This has not been
tested much if at all.
\item [Data Type] Integer
\item [Default] None.  Overture determines.
\end{description}

vflowinitx
\begin{description}
\item [Description] Specify an initial flow velocity in the vx direction.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

vflowinity
\begin{description}
\item [Description] Specify an initial flow velocity in the vy direction.
\item [Data Type] Real
\item [Default] 0.0
\end{description}

\noindent Parameters Describing Electrostatic (Poisson) Algorithm \\
\indent number\_of\_processors
\begin{description}
\item [Description] The electrostatic portion of the algorithm is 2D and is
distributed over different processors than are the 4D kinetic species.  You
may control this distribution through this parameter.  The intent is to
allow faster solves of Poisson's equation by distributing over multiple
processors and using a parallel Poisson solve.  The code currently does not
have access to a solver that shows speed up in parallel.  Therefore, you
should set this to 1 for now.
\item [Data Type] Integer
\item [Default] 1
\end{description}

\noindent Parameters Describing Electrodynamic (Maxwell) Algorithm \\
\indent number\_of\_processors
\begin{description}
\item [Description] The electrodynamic portion of the algorithm is 2D and is
distributed over different processors than are the 4D kinetic species.  You
may control this distribution through this parameter.  The intent is to
distribute the evaluation of the RHS of Maxwell's equations over multiple
processors.  In practice this has not proven to be needed and has not been
tested much if at all.  Therefore, you should set this to 1.
\item [Data Type] Integer
\item [Default] 1
\end{description}

avWeak
\begin{description}
\item [Description] Weak artificial dissipation term in evaluation of RHS of
Maxwell's equations.
\item [Data Type] Real
\item [Default] 0.1
\end{description}

avStrong
\begin{description}
\item [Description] Strong artificial dissipation term in evaluation of RHS of
Maxwell's equations.
\item [Data Type] Real
\item [Default] 0.1
\end{description}

\section*{Output Files}
Loki generates both restart files plot files.  The restart files contain the
state data necessary to restart a run from the point at which the file was
written.  Essentially this is the distribution functions and simulation time.
These files are written to the directory that was specified in the
restart.write\_directory input.  The names of the plot files and the frequency
at which they are written are controlled by the save\_data, show\_file\_name,
save\_times, and sequence\_write\_times input parameters.  All output files
generated by Loki are HDF5 files.  Any of the HDF5 binaries may be used to
examine the files or you may write your own HDF5 application to manipulate
them.  The matlab HDF5 interface may also be used to analyze these files.

It is important to note that Loki strictly enforces output file write times.
The code will adjust the simulation time step in order to ensure that plot
files are written at the exact time interval specified by the user.  It is
therefore safe to Fourier transform Loki output as the the time intervall of
this data is constant.

\subsection*{Post-Processing Output Files}
Once the post-processor has been run, several new files will be generated.  For
each restart dump a serialized output of the distribution functions will be
written.  If the prefix arg to the post-processor was xxx then for the n
restart dumps xxx\_dist\_n.hdf and xxx\_dist\_n.hdf.g0 will be generated.  The
first file contains meta-data and the latter contains the bulk data,
essentially the distribution functions.

All the plot files will be serialized into 2 new files.  Again, if the arg to
the post-processor was xxx then xxx\_fields.hdf and xxx\_timeSeries.hdf will be
generated.  The \_fields file contains all the 2D fields generated by Loki.
The \_timeSeries file contains all the 1D time histories generated by Loki.

\subsubsection*{2D Field Output}
The 2D fields produced by Loki depend whether a Vlasov-Poisson or
Vlasov-Maxwell system has been run.  In the case of a Vlasov-Poisson system,
the following plots are generated:
\begin{enumerate}
\item Ex
\item Ey \\
For each Kinetic Species:
\item Kinetic energy flux at vx low velocity boundary
\item Kinetic energy flux at vx high velocity boundary
\item Kinetic energy flux at vy low velocity boundary
\item Kinetic energy flux at vy high velocity boundary
\end{enumerate}
Therefore, if there are Ns species, there will be $4*Ns+2$ 2D fields generated
for a Vlasov-Poisson System.

In the case of a Vlasov-Maxwell system, the following plots are generated:
\begin{enumerate}
\item Ex
\item Ey
\item Ez
\item Bx
\item By
\item Bz \\
For each Kinetic Species:
\item Transverse drift velocity
\item Kinetic energy flux at vx low velocity boundary
\item Kinetic energy flux at vx high velocity boundary
\item Kinetic energy flux at vy low velocity boundary
\item Kinetic energy flux at vy high velocity boundary
\end{enumerate}
Therefore, if there are Ns species, there will be $5*Ns+6$ 2D fields generated
for a Vlasov-Maxwell system.

\subsubsection*{1D Time Histories}
The 1D time histories produced by Loki also depend on the system that has been
run.  In the case of a Vlasov-Poisson system, the following time histories are
generated:
\begin{enumerate}
\item maximal value of $\sqrt{(E_x^2 + E_y^2)}$
\item integral of $\sqrt{(E_x^2 + E_y^2)}$
\item maximal value of $abs(E_x)$
\item maximal value of $abs(E_y)$
\item integral of  $0.5*(E_x^2 + E_y^2)$ \\
For each probe:
\item $E_x$ at the probe
\item $E_y $ at the probe \\
For each tracking particle:
\item particle x position
\item particle y position
\item particle x velocity
\item particle y velocity \\
For each kinetic species:
\item integrated kinetic energy
\item kinetic energy flux through x low physical boundary
\item kinetic energy flux through x high physical boundary
\item kinetic energy flux through y low physical boundary
\item kinetic energy flux through y high physical boundary
\end{enumerate}
Therefore, if there are Ns species, Np probes, and Nt tracking particles there
will be $5+2*Np+4*Nt+5*Ns$ 1D time histories generated for a Vlasov-Poisson
system.

In the case of a Vlasov-Maxwell system, the following plots are generated:
\begin{enumerate}
\item maximal value of $\sqrt{(Ex^2 + Ey^2 + Ez^2)}$
\item integral of $\sqrt{(Ex^2 + Ey^2 + Ez^2)}$
\item maximal value of abs(Ex)
\item maximal value of abs(Ey)
\item maximal value of abs(Ez)
\item integral of $0.5*(Ex^2 + Ey^2 + Ez^2) $
\item maximal value of $\sqrt{(Bx^2 + By^2 + Bz^2)} $
\item integral of $\sqrt{(Bx^2 + By^2 + Bz^2) } $
\item maximal value of abs(Bx)
\item maximal value of abs(By)
\item maximual value of abs(Bz)
\item integral of $0.5*(Bx^2 + By^2 + Bz^2) $  \\
For each probe:
\item Ex at the probe
\item Ey at the probe
\item Ez at the probe
\item Bx at the probe
\item By at the probe
\item Bz at the probe
\item for each kinetic species: vz at the probe \\
For each tracking particle:
\item particle x position
\item particle y position
\item particle x velocity
\item particle y velocity \\
For each kinetic species:
\item integrated kinetic energy
\item kinetic energy flux through xlo physical boundary
\item kinetic energy flux through xhi physical boundary
\item kinetic energy flux through ylo physical boundary
\item kinetic energy flux through yhi physical boundary
\end{enumerate}
Therefore, if there are Ns species, Np probes, and Nt tracking particles there
will be $12+Np*(6+Ns)+4*Nt+5*Ns$ 1D time histories generated for a
Vlasov-Maxwell system.

\section*{testDist Utility}
This is a serial utility that takes 2 arguments, a proposed number of Vlasov
processors and the path to an input deck.  The utility determines the
decomposition of each kinetic species in the problem and, for each species,
prints out the smallest partition in each dimension.  If a partition is smaller
that the required minimum, the stencil width, a warning will be printed.

There are some general guidelines for choosing a good processor count.  The code
will assign processors to each kinetic species based on its proportion of the
total Vlasov work load.  The work load of a species is simply the product of its
4 phase space dimensions.  Thus, if there are 2 species of equal size each will
recieve 1/2 the Vlasov processors.  Similarly, if there are 2 species and one
is 2x the size of the other the smaller species will receive 1/3 the Vlasov
processors and the other 2/3.  In general, the ith species will receive
\begin{math} n_{i}/m \end{math} of the total number of Vlasov processors.  It
is best if the total number of Vlasov processors,
\begin {math} P_{v} \end{math}, contains a factor of m so that
\begin {math} P_{v} = m*P_{0} \end {math}.  This means that the ith kinetic
species will receive \begin {math} n_{i}*P_{0} \end {math} processors.  Further,
making \begin {math} P_{0} \end {math} a power of 2 gives the partitioning
algorithm maximum flexibility in partitioning each dimension thereby lessening
the possibility of overdecomposing a dimension.  For example 2 factors of 2
allows the algorithm to divide 2 comparably sized dimensions once each or one
very large dimension twice.  However one factor of 5 provides no flexibility
to the algorithm.  It can only divide the largest dimension by 5 which may be
too much.
\end{document}
